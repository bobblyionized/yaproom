<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>yaproom (official)</title>
  <style>
    /* GENERAL RESET & CONTAINER */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: #f8f8f8;
      color: #333;
      padding: 10px;
      transition: background 0.3s, color 0.3s;
    }
    .container {
      max-width: 480px;
      margin: 0 auto;
      padding: 10px;
    }
    /* CONTAINERS (Login, Chat, Settings) */
    #loginDiv, #chatDiv, #settingsDiv {
      background: #ffffff;
      border-radius: 8px;
      padding: 16px;
      margin-top: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    /* DARK MODE */
    body.dark-mode {
      background: #2f3136;
      color: #dcdcdc;
    }
    body.dark-mode #loginDiv,
    body.dark-mode #chatDiv,
    body.dark-mode #settingsDiv {
      background: #36393f;
      color: #dcdcdc;
    }
    body.dark-mode textarea {
      background: #40444b;
      color: #dcdcdc;
      border: 1px solid #4f545c;
    }
    body.dark-mode button {
      background: #4f545c;
      color: #dcdcdc;
      border: 1px solid #4f545c;
    }
    body.dark-mode select {
      background: #40444b;
      color: #dcdcdc;
      border: 1px solid #4f545c;
    }
    /* FORM ELEMENTS */
    input[type="text"], textarea, select {
      width: 100%;
      padding: 8px;
      margin-bottom: 8px;
      border: 1px solid #ccc;
      border-radius: 6px;
      font-size: 14px;
    }
    button {
      width: 100%;
      padding: 8px;
      border: none;
      border-radius: 6px;
      background: #7289da;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #677bc4;
    }
    /* HEADERS & TEXT */
    h2, h3 {
      margin-bottom: 12px;
      font-weight: 600;
    }
    p {
      margin-bottom: 8px;
      font-size: 14px;
    }
    .tutorial-box {
      background: #fafafa;
      padding: 6px;
      border-radius: 4px;
      font-size: 13px;
      margin-bottom: 8px;
    }
    body.dark-mode .tutorial-box {
      background: #40444b;
      color: #dcdcdc;
    }
    /* CHAT MESSAGES */
    #messages {
      list-style: none;
      padding: 0;
      max-height: 300px;
      overflow-y: auto;
      margin-bottom: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #ffffff;
    }
    body.dark-mode #messages {
      background: #40444b;
      border-color: #4f545c;
    }
    #messages li {
      padding: 6px 8px;
      border-bottom: 1px solid #eee;
      font-size: 14px;
    }
    #messages li:last-child {
      border-bottom: none;
    }
    .account-user {
      color: #7289da;
      font-weight: bold;
    }
    .anonymous-user {
      color: #333;
    }
    .broadcast-msg {
      background: #ffeb3b;
      color: #333;
      font-weight: bold;
      padding: 4px;
      border-radius: 4px;
    }
    /* TEXTAREA AUTO-RESIZE */
    textarea {
      resize: none;
      min-height: 40px;
      max-height: 120px;
      overflow-y: auto;
    }
    /* DM SECTION */
    #dmSection {
      margin-top: 10px;
      border-top: 1px solid #ccc;
      padding-top: 8px;
    }
    #dmMessages, #dm2Messages, #dm3Messages {
      list-style: none;
      padding: 0;
      max-height: 200px;
      overflow-y: auto;
      margin-bottom: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #ffffff;
    }
    body.dark-mode #dmMessages,
    body.dark-mode #dm2Messages,
    body.dark-mode #dm3Messages {
      background: #40444b;
      border-color: #4f545c;
    }
    #dmMessages li, #dm2Messages li, #dm3Messages li {
      padding: 6px 8px;
      border-bottom: 1px solid #eee;
      font-size: 14px;
    }
    /* MEMBER LIST - Expanded & Wider */
    #memberListContainer {
      width: 100%;  /* Ensure the container takes full available width */
      background: #ffffff;
      padding: 12px;
      margin-top: 10px;
      border: 1px solid #ddd;
      border-radius: 6px;
      min-height: 200px;
      max-height: 300px;
      overflow-y: auto;
    }
    body.dark-mode #memberListContainer {
      width: 100%;
      background: #36393f;
      border-color: #4f545c;
      min-height: 200px;
      max-height: 300px;
      overflow-y: auto;
    }
    #memberList li {
      padding: 4px 0;
      font-size: 14px;
    }
    /* MESSAGE ANIMATION */
    @keyframes message-enter {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .message-enter {
      animation: message-enter 0.3s ease forwards;
    }
    /* EXTRA SETTINGS HEADINGS */
    #settingsDiv h3 {
      margin-top: 16px;
      margin-bottom: 8px;
      font-weight: 600;
    }
    /* Hide audio elements */
    audio { display: none; }

    /* -------------------------------------------------------
       Changelog Overlay (SWORDBATTLE.IO STYLE - Unchanged, with indented bullets)
       ------------------------------------------------------- */
    #changelogOverlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.7);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 9999;
    }
    #changelogModal {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      max-width: 400px;
      width: 90%;
      color: #000;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    /* Indent bullet points */
    #changelogModal ul {
      margin: 10px 0;
      padding-left: 30px;
    }
  </style>
</head>
<body>
  <div class="container">
    <!-- Changelog Overlay -->
    <div id="changelogOverlay">
      <div id="changelogModal">
        <h2>Alpha V2.0.0</h2>
        <ul>
          <li>Cleaned up the UI for a modern light mode experience.</li>
          <li>Improved compact layout inspired by Discord mobile.</li>
          <li>Added background music controls, sound notifications, and message timestamp toggles in settings.</li>
          <li>Minor bug fixes and performance improvements.</li>
        </ul>
        <button onclick="closeChangelog()">Close</button>
      </div>
    </div>

    <!-- LOGIN SCREEN -->
    <div id="loginDiv">
      <h2>Enter Chat</h2>
      <p>Anonymous / Temporary Name:</p>
      <input type="text" id="anonymousInput" class="username-input" placeholder="Anonymous Name" />
      <button onclick="startChatting()" class="enter-chat-btn">Start Chatting</button>
      <hr />
      <h3>Account</h3>
      <div id="notLoggedInUI">
        <input type="text" id="accNameInput" placeholder="Desired username" />
        <input type="text" id="accPassInput" placeholder="Password" />
        <button onclick="createOrLoginAccount()">Create/Login Account</button>
      </div>
      <div id="loggedInUI" style="display:none;">
        <p>Logged in as: <span id="loggedInName"></span></p>
        <input type="text" id="renameInput" placeholder="New username" />
        <button onclick="renameAccount()">Rename Account</button>
        <br /><br />
        <input type="text" id="changePassInput" placeholder="New Password" />
        <button onclick="changePassword()">Change Password</button>
        <br /><br />
        <button onclick="logOutAccount()">Log Out</button>
      </div>
      <hr />
      <button onclick="showSettingsFromLogin()">Settings</button>
      <!-- OP-ONLY Section -->
      <div id="opSection" style="display:none; margin-top: 10px; border-top:1px solid #ccc; padding-top:10px;">
        <h3>OP Tools</h3>
        <button onclick="clearChatForEveryone()">Clear Chat (Server-Side)</button>
        <br /><br />
        <label for="opBroadcastInput">Broadcast Message:</label>
        <input type="text" id="opBroadcastInput" />
        <button onclick="sendBroadcast()">Send Broadcast</button>
        <br /><br />
        <label for="opColorPicker">Change Your Name Color:</label>
        <input type="color" id="opColorPicker" value="#7289da" />
        <button onclick="setOpColor()">Set Name Color</button>
        <br /><br />
        <button onclick="clearAllTyping()">Clear All 'Typing'</button>
      </div>
    </div>

    <!-- CHAT SCREEN -->
    <div id="chatDiv" style="display:none;">
      <h2>Yap Room</h2>
      <div class="tutorial-box">
        <strong>Group Chat Commands:</strong><br/>
        /createroom [roomName]<br/>
        /join [roomName]<br/>
        /invite [accountName]<br/>
        /leave
      </div>
      <ul id="messages"></ul>
      <div id="typingStatus"></div>
      <div class="chat-controls">
        <textarea id="messageInput" placeholder="Type a message" oninput="handleTyping()"></textarea>
        <button onclick="sendMessage()">Send</button>
        <button onclick="clearChat()">Clear Chat</button>
      </div>
      <!-- DM Section -->
      <div id="dmSection">
        <h3>Direct Messages</h3>
        <div id="dmLoginWarning" style="color:red; display:none;">You must be logged in to use DMs.</div>
        <div id="dmUI" style="display:none;">
          <!-- DM #1 -->
          <p><strong>DM #1</strong> – Type a username to DM:</p>
          <input type="text" id="dmTargetInput" placeholder="Username to DM" />
          <button onclick="openDM()">Open DM</button>
          <div id="dmConversation" style="display:none; margin-top:10px;">
            <ul id="dmMessages"></ul>
            <div class="dm-controls">
              <textarea id="dmMessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
              <button onclick="sendDM()">Send DM</button>
            </div>
          </div>
          <hr/>
          <!-- DM #2 -->
          <p><strong>DM #2</strong> – Type a username to DM:</p>
          <input type="text" id="dm2TargetInput" placeholder="Username to DM" />
          <button onclick="openDM2()">Open DM #2</button>
          <div id="dm2Conversation" style="display:none; margin-top:10px;">
            <ul id="dm2Messages"></ul>
            <div class="dm-controls">
              <textarea id="dm2MessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
              <button onclick="sendDM2()">Send DM #2</button>
            </div>
          </div>
          <hr/>
          <!-- DM #3 -->
          <p><strong>DM #3</strong> – Type a username to DM:</p>
          <input type="text" id="dm3TargetInput" placeholder="Username to DM" />
          <button onclick="openDM3()">Open DM #3</button>
          <div id="dm3Conversation" style="display:none; margin-top:10px;">
            <ul id="dm3Messages"></ul>
            <div class="dm-controls">
              <textarea id="dm3MessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
              <button onclick="sendDM3()">Send DM #3</button>
            </div>
          </div>
        </div>
      </div>
      <div id="memberListContainer">
        <h3>Members Online</h3>
        <ul id="memberList"></ul>
      </div>
      <div style="text-align:center; margin-top:10px;">
        <button onclick="returnToLogin()">Return to Main Screen</button>
      </div>
    </div>

    <!-- SETTINGS SCREEN -->
    <div id="settingsDiv" style="display:none;">
      <h2>Settings</h2>
      <!-- Basic Settings -->
      <label>
        <input type="checkbox" id="themeToggle" onchange="toggleDarkMode()" />
        Dark Mode
      </label>
      <br/><br/>
      <label for="guiSizeRange">GUI Size</label>
      <input type="range" id="guiSizeRange" min="0.5" max="2.0" step="0.1" value="1.0" onchange="updateGuiSize()" />
      <p id="guiSizeValue"></p>
      <label for="fontSelect">Choose Font:</label>
      <select id="fontSelect" onchange="updateFont()">
        <option value="font-arial">Arial</option>
        <option value="font-georgia">Georgia</option>
        <option value="font-courier">Courier New</option>
        <option value="font-comic">Comic Sans MS</option>
        <option value="font-roboto">Roboto</option>
        <option value="font-times">Times New Roman</option>
        <option value="font-verdana">Verdana</option>
        <option value="font-trebuchet">Trebuchet MS</option>
        <option value="font-lucida">Lucida Sans Unicode</option>
        <option value="font-garamond">Garamond</option>
      </select>
      <br/><br/>
      <label>
        <input type="checkbox" id="notificationsToggle" onchange="toggleNotifications()" />
        Enable Desktop Notifications
      </label>
      <br/><br/>
      <!-- Extra Settings Features -->
      <h3>Background Music</h3>
      <label for="musicFileInput">Upload Music:</label>
      <input type="file" id="musicFileInput" accept="audio/*" />
      <br/>
      <button onclick="toggleMusic()">Play/Pause Music</button>
      <label>Volume:</label>
      <input type="range" id="musicVolume" min="0" max="1" step="0.01" value="1" onchange="updateMusicVolume()" />
      <button onclick="clearMusic()">Remove Music</button>
      <br/><br/>
      <h3>Sound Notifications</h3>
      <label>
        <input type="checkbox" id="soundToggle" onchange="toggleSoundNotifications()" />
        Enable Chat Sound Notifications
      </label>
      <br/>
      <label for="soundVolume">Sound Volume:</label>
      <input type="range" id="soundVolume" min="0" max="1" step="0.01" value="1" onchange="updateSoundVolume()" />
      <br/><br/>
      <h3>Message Timestamps</h3>
      <label>
        <input type="checkbox" id="timestampToggle" onchange="toggleTimestamps()" />
        Show Message Timestamps (hover to view)
      </label>
      <br/><br/>
      <button onclick="goBack()">Back</button>
    </div>
  </div>

  <!-- Hidden Audio Elements -->
  <audio id="bgMusic" loop></audio>
  <audio id="chatSound" src="https://www.soundjay.com/button/beep-07.wav" preload="auto"></audio>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-database-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>

  <script>
    /* =====================================================
       Firebase Configuration & Initialization
       ===================================================== */
    const firebaseConfig = {
      apiKey: "AIzaSyBkm5Lf3PaghllqcatG_FymhTm_x7mGa28",
      authDomain: "yaproom-14cfe.firebaseapp.com",
      databaseURL: "https://yaproom-14cfe-default-rtdb.firebaseio.com",
      projectId: "yaproom-14cfe",
      storageBucket: "yaproom-14cfe.appspot.com",
      messagingSenderId: "5332542311",
      appId: "1:5332542311:web:f1a1ab2fb81bf62b0b45c2"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    /* =====================================================
       Global Variables & OP List
       ===================================================== */
    const OP_LIST = ["god", "nubunknown", "pasta"];
    let lastMessageTime = 2000;
    const RATE_LIMIT_MS = 2000;
    const badWords = ["shit","fuck","bitch","nigga","fucking","shitting","negro","bullshit","pussy"];
    let currentUsername = null;
    let currentPassHash = null;
    let accountDeletedRef = null;
    let renamingInProgress = false;
    let currentDMPath = null, dmListener = null;
    let currentDM2Path = null, dm2Listener = null;
    let currentDM3Path = null, dm3Listener = null;
    let inGroupChat = false, currentGroupRoomName = null, groupListener = null;
    let typingTimeout = null;
    let mutedUsers = {};
    let accountColors = {};
    let publicMessages = [];
    let publicListenerAdd = null, publicListenerRemove = null;
    let myPresenceRef = null;

    /* =====================================================
       On Page Load
       ===================================================== */
    window.onload = function() {
      document.getElementById("changelogOverlay").style.display = "flex";
      // Dark Mode
      const darkModeEnabled = localStorage.getItem("darkModeEnabled") === "true";
      if (darkModeEnabled) document.body.classList.add("dark-mode");
      document.getElementById("themeToggle").checked = darkModeEnabled;
      // GUI Size
      const savedScale = localStorage.getItem("uiScale");
      if (savedScale) {
        document.documentElement.style.fontSize = (16 * savedScale) + "px";
        document.getElementById("guiSizeRange").value = savedScale;
      }
      updateGuiSizeDisplay();
      // Font
      const savedFont = localStorage.getItem("selectedFont") || "font-arial";
      document.body.classList.add(savedFont);
      document.getElementById("fontSelect").value = savedFont;
      // Account
      currentUsername = localStorage.getItem("acc_username");
      currentPassHash = localStorage.getItem("acc_passHash");
      updateAccountUI();
      // Public Chat Listener
      startPublicChatListeners();
      // Typing Updates
      db.ref("typing").on("value", (snap) => {
        const typingObj = snap.val() || {};
        showTypingStatus(typingObj);
      });
      // Muted Users
      db.ref("mutedUsers").on("value", (snap) => { mutedUsers = snap.val() || {}; });
      // Account Colors
      db.ref("accountColors").on("value", (snap) => { accountColors = snap.val() || {}; });
      // Broadcasts
      db.ref("broadcasts").on("child_added", (snap) => {
        const bData = snap.val();
        displayMessage(bData.user, bData.text, true, true, snap.key);
      });
      db.ref("broadcasts").on("child_removed", (snap) => {
        const removedKey = snap.key;
        const li = document.querySelector(`li[data-key="${removedKey}"]`);
        if (li) li.remove();
      });
      // Presence
      db.ref("presence").on("value", (snapshot) => {
        const presenceData = snapshot.val() || {};
        let members = [];
        for (let key in presenceData) {
          if (presenceData[key].username) { members.push(presenceData[key].username); }
        }
        updateMemberList(members);
      });
      // Textarea Shortcuts
      setupTextareaShortcuts("messageInput", sendMessage);
      setupTextareaShortcuts("dmMessageInput", sendDM);
      setupTextareaShortcuts("dm2MessageInput", sendDM2);
      setupTextareaShortcuts("dm3MessageInput", sendDM3);
      // Notifications Setting
      const notificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      document.getElementById("notificationsToggle").checked = notificationsEnabled;
      // Sound Notifications Setting
      const soundEnabled = localStorage.getItem("soundNotificationsEnabled") === "true";
      document.getElementById("soundToggle").checked = soundEnabled;
      const savedSoundVolume = localStorage.getItem("soundVolume");
      if (savedSoundVolume) {
        document.getElementById("soundVolume").value = savedSoundVolume;
        document.getElementById("chatSound").volume = parseFloat(savedSoundVolume);
      }
      // Message Timestamps Toggle
      const showTimestamps = localStorage.getItem("showTimestamps") === "true";
      document.getElementById("timestampToggle").checked = showTimestamps;
      // Remove typing on unload
      window.onbeforeunload = () => removeUserTyping();
      // Background Music
      const storedMusic = localStorage.getItem("bgMusic");
      if (storedMusic) {
        document.getElementById("bgMusic").src = storedMusic;
        document.getElementById("bgMusic").volume = localStorage.getItem("musicVolume") || 1;
        document.getElementById("bgMusic").play();
      }
    };

    function closeChangelog() {
      document.getElementById("changelogOverlay").style.display = "none";
    }

    function setupTextareaShortcuts(textareaId, sendCallback) {
      const textarea = document.getElementById(textareaId);
      textarea.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendCallback();
        }
      });
      textarea.addEventListener("input", autoResize);
    }

    function autoResize(event) {
      const textarea = event.target;
      textarea.style.height = "auto";
      textarea.style.height = (textarea.scrollHeight) + "px";
    }

    /* =====================================================
       Public Chat Listener
       ===================================================== */
    function startPublicChatListeners() {
      db.ref("messages").off("child_added", publicListenerAdd);
      db.ref("messages").off("child_removed", publicListenerRemove);
      publicMessages = [];
      document.getElementById("messages").innerHTML = "";
      publicListenerAdd = db.ref("messages").on("child_added", (snapshot) => {
        const msg = snapshot.val();
        const key = snapshot.key;
        if (msg.user && mutedUsers[msg.user]) return;
        publicMessages.push({ key, ...msg });
        if (!inGroupChat) {
          displayMessage(msg.user, msg.text, msg.isAccount, false, key, msg.timestamp);
        }
        if (msg.user && msg.text) { checkForMentionsAndNotify(msg.user, msg.text); }
      });
      publicListenerRemove = db.ref("messages").on("child_removed", (snap) => {
        const removedKey = snap.key;
        publicMessages = publicMessages.filter(m => m.key !== removedKey);
        if (!inGroupChat) {
          const li = document.querySelector(`li[data-key="${removedKey}"]`);
          if (li) li.remove();
        }
      });
    }

    function checkForMentionsAndNotify(sender, text) {
      if (!currentUsername || !text) return;
      const textLower = text.toLowerCase();
      const mentionString = "@" + currentUsername.toLowerCase();
      if (textLower.includes(mentionString) && sender !== currentUsername) {
        showMentionNotification(sender, text);
      }
    }

    function showMentionNotification(sender, text) {
      const isNotificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      if (!("Notification" in window) || !isNotificationsEnabled) return;
      if (document.hidden && Notification.permission === "granted") {
        new Notification("You were mentioned by " + sender, {
          body: text,
          icon: "https://via.placeholder.com/50"
        });
      }
    }

    /* =====================================================
       Account Creation / Login
       ===================================================== */
    async function createOrLoginAccount() {
      const desiredName = document.getElementById("accNameInput").value.trim();
      const desiredPass = document.getElementById("accPassInput").value.trim();
      if (!desiredName || !desiredPass) {
        alert("Please provide both a username and a password.");
        return;
      }
      if (/\s/.test(desiredName)) {
        alert("Usernames cannot contain spaces.");
        return;
      }
      const passHash = sha256(desiredPass);
      try {
        const snap = await db.ref("accounts/" + desiredName).once("value");
        if (!snap.exists()) {
          await db.ref("accounts/" + desiredName).set({
            passwordHash: passHash,
            createdAt: Date.now()
          });
          alert("Account created! Logged in as: " + desiredName);
        } else {
          const data = snap.val();
          if (data.passwordHash !== passHash) {
            alert("Incorrect password or name is taken by someone else.");
            return;
          }
          alert("Logged in successfully as: " + desiredName);
        }
        currentUsername = desiredName;
        currentPassHash = passHash;
        localStorage.setItem("acc_username", currentUsername);
        localStorage.setItem("acc_passHash", currentPassHash);
        updateAccountUI();
      } catch (err) {
        alert("Error creating/logging in: " + err);
      }
    }

    function updateAccountUI() {
      const notLoggedInUI = document.getElementById("notLoggedInUI");
      const loggedInUI = document.getElementById("loggedInUI");
      const loggedInName = document.getElementById("loggedInName");
      const anonInput = document.getElementById("anonymousInput");
      if (currentUsername && currentPassHash) {
        notLoggedInUI.style.display = "none";
        loggedInUI.style.display = "block";
        loggedInName.textContent = currentUsername;
        anonInput.value = currentUsername;
        anonInput.disabled = true;
        listenForAccountDeletion();
      } else {
        notLoggedInUI.style.display = "block";
        loggedInUI.style.display = "none";
        anonInput.value = "";
        anonInput.disabled = false;
        if (accountDeletedRef) { accountDeletedRef.off("value"); accountDeletedRef = null; }
      }
      updateDMUI();
      checkIfOP();
    }

    function listenForAccountDeletion() {
      if (accountDeletedRef) { accountDeletedRef.off("value"); accountDeletedRef = null; }
      if (!currentUsername) return;
      accountDeletedRef = db.ref("accounts/" + currentUsername);
      accountDeletedRef.on("value", (snap) => {
        if (!snap.exists() && !renamingInProgress) {
          alert("Your account has been terminated!");
          logOutAccount();
        }
      });
    }

    async function logOutAccount() {
      removeUserTyping();
      if (accountDeletedRef) { accountDeletedRef.off("value"); accountDeletedRef = null; }
      if (myPresenceRef) { myPresenceRef.remove(); myPresenceRef = null; }
      localStorage.removeItem("acc_username");
      localStorage.removeItem("acc_passHash");
      currentUsername = null;
      currentPassHash = null;
      alert("Logged out.");
      updateAccountUI();
    }

    function removeUserTyping() {
      if (currentUsername) { db.ref("typing/" + currentUsername).remove(); }
    }

    /* =====================================================
       Rename Account (12-hour lock)
       ===================================================== */
    async function renameAccount() {
      if (!currentUsername || !currentPassHash) {
        alert("You are not logged in, can't rename.");
        return;
      }
      const newName = document.getElementById("renameInput").value.trim();
      if (!newName) {
        alert("Enter a new username.");
        return;
      }
      if (/\s/.test(newName)) {
        alert("Usernames cannot contain spaces!");
        return;
      }
      const currentAccountSnap = await db.ref("accounts/" + currentUsername).once("value");
      if (!currentAccountSnap.exists()) {
        alert("Your account no longer exists or was deleted.");
        return;
      }
      const currentAccData = currentAccountSnap.val();
      const lastRenamed = currentAccData.lastRenamed || 0;
      const now = Date.now();
      const TWELVE_HOURS = 12 * 60 * 60 * 1000;
      if (now - lastRenamed < TWELVE_HOURS) {
        const timeLeftMs = TWELVE_HOURS - (now - lastRenamed);
        const timeLeftHr = Math.ceil(timeLeftMs / (1000 * 60 * 60));
        alert(`You must wait ${timeLeftHr} more hour(s) before renaming again!`);
        return;
      }
      const snap = await db.ref("accounts/" + newName).once("value");
      if (snap.exists()) {
        alert("That username is taken.");
        return;
      }
      try {
        renamingInProgress = true;
        await db.ref("accounts/" + currentUsername).remove();
        await db.ref("accounts/" + newName).set({
          passwordHash: currentPassHash,
          createdAt: currentAccData.createdAt,
          lastRenamed: now
        });
        db.ref("typing/" + currentUsername).remove();
        currentUsername = newName;
        localStorage.setItem("acc_username", currentUsername);
        if (myPresenceRef) { myPresenceRef.update({ username: newName }); }
        alert("Renamed to " + newName);
        renamingInProgress = false;
        updateAccountUI();
      } catch (err) {
        renamingInProgress = false;
        alert("Error renaming: " + err);
      }
    }

    /* =====================================================
       Change Password
       ===================================================== */
    async function changePassword() {
      if (!currentUsername || !currentPassHash) {
        alert("You are not logged in, can't change password.");
        return;
      }
      const newPass = document.getElementById("changePassInput").value.trim();
      if (!newPass) {
        alert("Enter a new password.");
        return;
      }
      const newPassHash = sha256(newPass);
      try {
        await db.ref("accounts/" + currentUsername).update({
          passwordHash: newPassHash
        });
        currentPassHash = newPassHash;
        localStorage.setItem("acc_passHash", newPassHash);
        alert("Password changed successfully!");
        document.getElementById("changePassInput").value = "";
      } catch (err) {
        alert("Error changing password: " + err);
      }
    }

    /* =====================================================
       Starting Chat & Presence
       ===================================================== */
    function startChatting() {
      if (!currentUsername) {
        const anonName = document.getElementById("anonymousInput").value.trim();
        if (!anonName) {
          alert("Please enter a name or create an account.");
          return;
        }
        if (/\s/.test(anonName)) {
          alert("Usernames cannot contain spaces.");
          return;
        }
        currentUsername = anonName;
      }
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("chatDiv").style.display = "block";
      updateDMUI();
      setupPresence();
    }

    function returnToLogin() {
      removeUserTyping();
      if (myPresenceRef) { myPresenceRef.remove(); myPresenceRef = null; }
      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
      checkIfOP();
    }

    /* =====================================================
       Public Chat Send
       ===================================================== */
    function filterBadWords(text) {
      const badWordsLower = badWords.map(word => word.toLowerCase());
      let filtered = text;
      badWordsLower.forEach(word => {
        const regex = new RegExp("\\b" + word + "\\b", "gi");
        filtered = filtered.replace(regex, "****");
      });
      return filtered;
    }

    function sendMessage() {
      const inp = document.getElementById("messageInput");
      let text = inp.value.trim();
      if (!text) return;
      if (text.startsWith("/")) {
        handleSlashCommand(text);
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const currentTime = Date.now();
      if (currentTime - lastMessageTime < RATE_LIMIT_MS) {
        const secLeft = Math.ceil((RATE_LIMIT_MS - (currentTime - lastMessageTime)) / 1000);
        alert(`Wait ${secLeft} second(s).`);
        return;
      }
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      text = filterBadWords(text);
      let finalName = currentUsername || "Unknown";
      const isAccount = (currentUsername && currentPassHash);
      if (inGroupChat && currentGroupRoomName) {
        db.ref("groupRooms/" + currentGroupRoomName + "/messages").push({
          user: finalName,
          text: text,
          timestamp: firebase.database.ServerValue.TIMESTAMP
        });
      } else {
        db.ref("messages").push({
          user: finalName,
          text: text,
          isAccount: isAccount,
          timestamp: firebase.database.ServerValue.TIMESTAMP
        });
      }
      inp.value = "";
      inp.style.height = "40px";
      lastMessageTime = currentTime;
      if (currentUsername) { db.ref("typing/" + currentUsername).remove(); }
    }

    function displayMessage(user, text, isAccount, isBroadcast, messageKey, timestamp) {
      const ul = document.getElementById("messages");
      const li = document.createElement("li");
      li.classList.add("message-enter");
      if (messageKey) { li.setAttribute("data-key", messageKey); }
      let userColorClass = isAccount ? "account-user" : "anonymous-user";
      let colorStyle = "";
      if (accountColors[user]) {
        colorStyle = `style="color:${accountColors[user]}; font-weight:bold;"`;
      } else if (isAccount) {
        colorStyle = `style="color:#7289da;"`;
      }
      if (isBroadcast) {
        li.innerHTML = `<span class="broadcast-msg">[BROADCAST from ${user}]</span> ${text}`;
      } else {
        li.innerHTML = `<span class="${userColorClass}" ${colorStyle}>${user}</span>: ${text}`;
      }
      if (localStorage.getItem("showTimestamps") === "true" && timestamp) {
        const date = new Date(timestamp);
        li.title = date.toLocaleString();
      }
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function clearChat() {
      const confirmClear = confirm("Are you sure you want to clear the chat messages on your screen?");
      if (!confirmClear) return;
      document.getElementById("messages").innerHTML = "";
    }

    /* =====================================================
       Typing Indicators
       ===================================================== */
    function handleTyping() {
      if (!currentUsername) return;
      db.ref("typing/" + currentUsername).set(true);
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => { db.ref("typing/" + currentUsername).remove(); }, 3000);
    }

    function showTypingStatus(typingObj) {
      const keys = Object.keys(typingObj).filter(u => u !== currentUsername);
      const typingDiv = document.getElementById("typingStatus");
      if (keys.length === 0) { typingDiv.textContent = ""; }
      else if (keys.length === 1) { typingDiv.textContent = `${keys[0]} is typing...`; }
      else { typingDiv.textContent = `${keys.join(", ")} are typing...`; }
    }

    /* =====================================================
       Multiple DM Support
       ===================================================== */
    function updateDMUI() {
      const warn = document.getElementById("dmLoginWarning");
      const ui = document.getElementById("dmUI");
      if (currentUsername && currentPassHash) { warn.style.display = "none"; ui.style.display = "block"; }
      else { warn.style.display = "block"; ui.style.display = "none"; }
    }

    // DM #1
    function openDM() {
      const typedName = document.getElementById("dmTargetInput").value.trim();
      if (!typedName) { alert("Please type a username to DM."); return; }
      if (!currentUsername || !currentPassHash) { alert("You must be logged in to DM."); return; }
      if (dmListener && currentDMPath) { db.ref(currentDMPath).off("child_added", dmListener); }
      const userA = currentUsername;
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDMPath = "dms/" + dmKey;
      document.getElementById("dmMessages").innerHTML = "";
      document.getElementById("dmConversation").style.display = "block";
      dmListener = db.ref(currentDMPath).on("child_added", (snap) => {
        const val = snap.val();
        displayDMMessage(val.user, val.text);
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
          playSoundNotification();
        }
      });
    }

    function displayDMMessage(sender, text) {
      const ul = document.getElementById("dmMessages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM() {
      if (!currentDMPath) { alert("No DM open. Type a username and 'Open DM' first."); return; }
      const inp = document.getElementById("dmMessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterBadWords(text);
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUsername || "Unknown";
      db.ref(currentDMPath).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    // DM #2
    function openDM2() {
      const typedName = document.getElementById("dm2TargetInput").value.trim();
      if (!typedName) { alert("Please type a username to DM (DM #2)."); return; }
      if (!currentUsername || !currentPassHash) { alert("You must be logged in to DM."); return; }
      if (dm2Listener && currentDM2Path) { db.ref(currentDM2Path).off("child_added", dm2Listener); }
      const userA = currentUsername;
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDM2Path = "dms/" + dmKey;
      document.getElementById("dm2Messages").innerHTML = "";
      document.getElementById("dm2Conversation").style.display = "block";
      dm2Listener = db.ref(currentDM2Path).on("child_added", (snap) => {
        const val = snap.val();
        displayDM2Message(val.user, val.text);
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
          playSoundNotification();
        }
      });
    }

    function displayDM2Message(sender, text) {
      const ul = document.getElementById("dm2Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM2() {
      if (!currentDM2Path) { alert("No DM #2 open. Type a username and 'Open DM #2' first."); return; }
      const inp = document.getElementById("dm2MessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterBadWords(text);
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUsername || "Unknown";
      db.ref(currentDM2Path).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    // DM #3
    function openDM3() {
      const typedName = document.getElementById("dm3TargetInput").value.trim();
      if (!typedName) { alert("Please type a username to DM (DM #3)."); return; }
      if (!currentUsername || !currentPassHash) { alert("You must be logged in to DM."); return; }
      if (dm3Listener && currentDM3Path) { db.ref(currentDM3Path).off("child_added", dm3Listener); }
      const userA = currentUsername;
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDM3Path = "dms/" + dmKey;
      document.getElementById("dm3Messages").innerHTML = "";
      document.getElementById("dm3Conversation").style.display = "block";
      dm3Listener = db.ref(currentDM3Path).on("child_added", (snap) => {
        const val = snap.val();
        displayDM3Message(val.user, val.text);
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
          playSoundNotification();
        }
      });
    }

    function displayDM3Message(sender, text) {
      const ul = document.getElementById("dm3Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM3() {
      if (!currentDM3Path) { alert("No DM #3 open. Type a username and 'Open DM' first."); return; }
      const inp = document.getElementById("dm3MessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterBadWords(text);
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUsername || "Unknown";
      db.ref(currentDM3Path).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    /* =====================================================
       Group Chat (Slash Commands)
       ===================================================== */
    async function handleSlashCommand(text) {
      const parts = text.split(" ");
      const cmd = parts[0].toLowerCase();
      const arg = parts[1] ? parts[1].trim() : null;
      if (isCurrentUserOP()) {
        if (cmd === "/mute" || cmd === "/unmute") {
          handleOpCommand(cmd, arg);
          return;
        }
        if (cmd === "/terminate") {
          if (!arg) { alert("Usage: /terminate [accountName]"); }
          else { terminateAccount(arg); }
          return;
        }
      }
      switch(cmd) {
        case "/createroom":
          if (!arg) { alert("Usage: /createroom [roomName]"); return; }
          await createGroupRoom(arg);
          break;
        case "/join":
          if (!arg) { alert("Usage: /join [roomName]"); return; }
          await joinGroupRoom(arg);
          break;
        case "/invite":
          if (!arg) { alert("Usage: /invite [accountName]"); return; }
          await inviteToGroup(arg);
          break;
        case "/leave":
          leaveGroupRoom();
          break;
        default:
          alert("Unknown command.");
      }
    }

    async function createGroupRoom(roomName) {
      if (!currentUsername || !currentPassHash) {
        alert("You must be logged in to create a group room.");
        return;
      }
      const snap = await db.ref("groupRooms/" + roomName).once("value");
      if (snap.exists()) {
        alert("That room name already exists. Choose a different one.");
        return;
      }
      await db.ref("groupRooms/" + roomName).set({
        participants: [currentUsername],
        createdAt: Date.now(),
        messages: { dummy: { system: "Group created" } }
      });
      alert(`Group room "${roomName}" created. You are now inside it.`);
      joinGroupRoom(roomName);
    }

    async function joinGroupRoom(roomName) {
      if (!currentUsername || !currentPassHash) {
        alert("You must be logged in to join a group room.");
        return;
      }
      const snap = await db.ref("groupRooms/" + roomName).once("value");
      if (!snap.exists()) {
        alert("That room does not exist.");
        return;
      }
      const roomData = snap.val();
      const me = currentUsername;
      if (!roomData.participants || !roomData.participants.includes(me)) {
        if (isCurrentUserOP()) {
          let updated = roomData.participants || [];
          if (!updated.includes(me)) {
            updated.push(me);
            await db.ref("groupRooms/" + roomName + "/participants").set(updated);
          }
          await db.ref("groupRooms/" + roomName + "/messages").push({
            system: `${currentUsername} (OP) joined the room without invite.`
          });
        } else {
          alert("You are not invited to this room. Ask someone to /invite you.");
          return;
        }
      }
      inGroupChat = true;
      document.getElementById("messages").innerHTML = "";
      if (groupListener) { db.ref("groupRooms/" + currentGroupRoomName + "/messages").off("child_added", groupListener); }
      currentGroupRoomName = roomName;
      groupListener = db.ref("groupRooms/" + roomName + "/messages").on("child_added", (snapMsg) => {
        const val = snapMsg.val();
        if (val.user && val.text) {
          if (mutedUsers[val.user]) return;
          displayMessage(val.user, val.text, true, false, snapMsg.key, val.timestamp);
          checkForMentionsAndNotify(val.user, val.text);
        } else if (val.system) {
          displayMessage("System", val.system, false, false, snapMsg.key);
        }
      });
      alert(`You joined group room "${roomName}". All new messages go there.`);
    }

    async function inviteToGroup(accountName) {
      if (!inGroupChat || !currentGroupRoomName) {
        alert("You are not in a group room. Use /join [roomName] first.");
        return;
      }
      const roomRef = db.ref("groupRooms/" + currentGroupRoomName + "/participants");
      const snap = await roomRef.once("value");
      const participants = snap.val() || [];
      if (!participants.includes(accountName)) { participants.push(accountName); }
      await roomRef.set(participants);
      db.ref("groupRooms/" + currentGroupRoomName + "/messages").push({ system: `${accountName} has been invited.` });
      alert(`${accountName} invited to "${currentGroupRoomName}".`);
    }

    function leaveGroupRoom() {
      if (!inGroupChat) {
        alert("You are not in a group room.");
        return;
      }
      if (groupListener && currentGroupRoomName) {
        db.ref("groupRooms/" + currentGroupRoomName + "/messages").off("child_added", groupListener);
      }
      document.getElementById("messages").innerHTML = "";
      inGroupChat = false;
      currentGroupRoomName = null;
      publicMessages.forEach(msg => {
        displayMessage(msg.user, msg.text, msg.isAccount, false, msg.key, msg.timestamp);
      });
      alert("You left the group room. Back to public chat.");
    }

    /* =====================================================
       OP Commands & Tools
       ===================================================== */
    function isCurrentUserOP() {
      return currentUsername && OP_LIST.includes(currentUsername.toLowerCase());
    }

    function checkIfOP() {
      const opSection = document.getElementById("opSection");
      opSection.style.display = isCurrentUserOP() ? "block" : "none";
    }

    function handleOpCommand(cmd, target) {
      if (!target) { alert("Usage: " + cmd + " [username]"); return; }
      if (cmd === "/mute") {
        db.ref("mutedUsers/" + target).set(true);
        alert(`User "${target}" has been muted.`);
      } else if (cmd === "/unmute") {
        db.ref("mutedUsers/" + target).remove();
        alert(`User "${target}" has been unmuted.`);
      }
    }

    async function terminateAccount(target) {
      const confirmTerm = confirm(`Are you sure you want to TERMINATE the account "${target}"? This is permanent!`);
      if (!confirmTerm) return;
      try {
        await db.ref("accounts/" + target).remove();
        await db.ref("accountColors/" + target).remove();
        await db.ref("typing/" + target).remove();
        await db.ref("mutedUsers/" + target).remove();
        const msgsSnap = await db.ref("messages").once("value");
        msgsSnap.forEach((childSnap) => {
          const val = childSnap.val();
          if (val.user && val.user === target) { childSnap.ref.remove(); }
        });
        const dmsSnap = await db.ref("dms").once("value");
        dmsSnap.forEach((dmRoomSnap) => {
          dmRoomSnap.forEach((msgSnap) => {
            const msgVal = msgSnap.val();
            if (msgVal.user && msgVal.user === target) { msgSnap.ref.remove(); }
          });
        });
        const groupsSnap = await db.ref("groupRooms").once("value");
        groupsSnap.forEach((roomSnap) => {
          const roomData = roomSnap.val();
          if (!roomData) return;
          if (roomData.participants) {
            const updated = roomData.participants.filter(p => p !== target);
            if (updated.length !== roomData.participants.length) { roomSnap.ref.child("participants").set(updated); }
          }
          if (roomData.messages) {
            Object.keys(roomData.messages).forEach((mKey) => {
              const mVal = roomData.messages[mKey];
              if (mVal.user && mVal.user === target) { roomSnap.ref.child("messages").child(mKey).remove(); }
            });
          }
        });
        alert(`Account "${target}" has been TERMINATED.`);
      } catch (err) {
        alert("Error terminating account: " + err);
      }
    }

    async function clearChatForEveryone() {
      const confirmClear = confirm("Are you sure you want to clear the public chat AND all broadcasts for EVERYONE?");
      if (!confirmClear) return;
      await db.ref("messages").remove();
      await db.ref("broadcasts").remove();
      document.getElementById("messages").innerHTML = "";
      publicMessages = [];
      alert("All messages and broadcasts cleared for everyone.");
    }

    function sendBroadcast() {
      if (!isCurrentUserOP()) { alert("You are not an OP!"); return; }
      const broadcastInput = document.getElementById("opBroadcastInput");
      const text = broadcastInput.value.trim();
      if (!text) return;
      db.ref("broadcasts").push({
        user: currentUsername,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      broadcastInput.value = "";
      alert("Broadcast sent!");
    }

    function setOpColor() {
      if (!isCurrentUserOP()) { alert("You are not an OP!"); return; }
      const colorPicker = document.getElementById("opColorPicker");
      const chosenColor = colorPicker.value;
      db.ref("accountColors/" + currentUsername).set(chosenColor);
      alert("Your chat color has been updated to: " + chosenColor);
    }

    function clearAllTyping() {
      if (!isCurrentUserOP()) { alert("You are not an OP!"); return; }
      db.ref("typing").remove();
      alert("All 'typing' statuses have been cleared for everyone.");
    }

    /* =====================================================
       Settings Navigation
       ===================================================== */
    function showSettingsFromLogin() {
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("settingsDiv").style.display = "block";
    }

    function goBack() {
      document.getElementById("settingsDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
    }

    /* =====================================================
       Dark Mode Toggle
       ===================================================== */
    function toggleDarkMode() {
      document.body.classList.toggle("dark-mode");
      const isDark = document.body.classList.contains("dark-mode");
      localStorage.setItem("darkModeEnabled", isDark);
    }

    /* =====================================================
       GUI Size
       ===================================================== */
    function updateGuiSize() {
      const scale = document.getElementById("guiSizeRange").value;
      document.documentElement.style.fontSize = (16 * scale) + "px";
      localStorage.setItem("uiScale", scale);
      updateGuiSizeDisplay();
    }

    function updateGuiSizeDisplay() {
      const val = document.getElementById("guiSizeRange").value;
      document.getElementById("guiSizeValue").textContent = `Current Scale: ${val}x`;
    }

    /* =====================================================
       Custom Font
       ===================================================== */
    function updateFont() {
      document.body.classList.remove(
        "font-arial", "font-georgia", "font-courier", "font-comic", "font-roboto",
        "font-times", "font-verdana", "font-trebuchet", "font-lucida", "font-garamond"
      );
      const selectedFont = document.getElementById("fontSelect").value;
      document.body.classList.add(selectedFont);
      localStorage.setItem("selectedFont", selectedFont);
    }

    /* =====================================================
       Desktop Notifications
       ===================================================== */
    function toggleNotifications() {
      const isChecked = document.getElementById("notificationsToggle").checked;
      localStorage.setItem("notificationsEnabled", isChecked);
      if (isChecked) { requestNotificationPermission(); }
    }

    function requestNotificationPermission() {
      if (!("Notification" in window)) {
        alert("This browser does not support desktop notifications.");
        return;
      }
      if (Notification.permission !== "granted") {
        Notification.requestPermission().then((permission) => {
          if (permission !== "granted") {
            alert("You blocked notifications in your browser settings.");
            document.getElementById("notificationsToggle").checked = false;
            localStorage.setItem("notificationsEnabled", false);
          }
        });
      }
    }

    function showDMNotification(user, text) {
      const isNotificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      if (!("Notification" in window) || !isNotificationsEnabled) return;
      if (document.hidden && Notification.permission === "granted") {
        new Notification("New DM from " + user, {
          body: text,
          icon: "https://via.placeholder.com/50"
        });
      }
    }

    /* =====================================================
       Member List (Presence)
       ===================================================== */
    function setupPresence() {
      if (myPresenceRef) { myPresenceRef.remove(); myPresenceRef = null; }
      const userNameForPresence = currentUsername || ("Guest_" + Math.floor(Math.random() * 10000));
      myPresenceRef = db.ref("presence").push();
      myPresenceRef.set({
        username: userNameForPresence,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      myPresenceRef.onDisconnect().remove();
    }

    function updateMemberList(members) {
      const uniqueMembers = {};
      members.forEach(member => { uniqueMembers[member] = (uniqueMembers[member] || 0) + 1; });
      const memberListUl = document.getElementById("memberList");
      memberListUl.innerHTML = "";
      for (let member in uniqueMembers) {
        const count = uniqueMembers[member];
        const li = document.createElement("li");
        li.textContent = member + (count > 1 ? " (" + count + ")" : "");
        memberListUl.appendChild(li);
      }
    }

    /* =====================================================
       NEW SETTINGS FEATURES
       ===================================================== */
    // --- Background Music Controls ---
    const bgMusic = document.getElementById("bgMusic");
    const musicFileInput = document.getElementById("musicFileInput");
    const musicVolume = document.getElementById("musicVolume");
    musicFileInput.addEventListener("change", function() {
      const file = this.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          bgMusic.src = e.target.result;
          localStorage.setItem("bgMusic", e.target.result);
          bgMusic.play();
        };
        reader.readAsDataURL(file);
      }
    });
    function toggleMusic() {
      if (bgMusic.paused) { bgMusic.play(); } else { bgMusic.pause(); }
    }
    function updateMusicVolume() {
      const vol = musicVolume.value;
      bgMusic.volume = vol;
      localStorage.setItem("musicVolume", vol);
    }
    function clearMusic() {
      bgMusic.pause();
      bgMusic.src = "";
      localStorage.removeItem("bgMusic");
      alert("Background music removed!");
    }
    // --- Chat Sound Notifications ---
    const chatSound = document.getElementById("chatSound");
    const soundToggle = document.getElementById("soundToggle");
    const soundVolume = document.getElementById("soundVolume");
    function toggleSoundNotifications() {
      const enabled = soundToggle.checked;
      localStorage.setItem("soundNotificationsEnabled", enabled);
    }
    function updateSoundVolume() {
      const vol = soundVolume.value;
      chatSound.volume = vol;
      localStorage.setItem("soundVolume", vol);
    }
    function playSoundNotification() {
      const enabled = localStorage.getItem("soundNotificationsEnabled") === "true";
      if (enabled) { chatSound.currentTime = 0; chatSound.play(); }
    }
    // --- Message Timestamps Toggle ---
    function toggleTimestamps() {
      const enabled = document.getElementById("timestampToggle").checked;
      localStorage.setItem("showTimestamps", enabled);
      alert("Message timestamp display " + (enabled ? "enabled" : "disabled") + ". (Hover over messages to see the sent time.)");
    }
  </script>
</body>
</html>
