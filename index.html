<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Yaproom (Official) - v201</title>
  <style>
    /* GENERAL RESET & CONTAINER */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: #f8f8f8; color: #333; padding: 10px;
      transition: background 0.3s, color 0.3s;
    }
    .container { max-width: 480px; margin: 0 auto; padding: 10px; }
    /* CONTAINERS (Login, Chat, Settings, Duel Speed Game, RPS Game) */
    #loginDiv, #chatDiv, #settingsDiv, #duelSpeedGameDiv, #rpsGameDiv {
      background: #ffffff; border-radius: 8px; padding: 16px; margin-top: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    /* Duel Speed Game UI */
    #duelSpeedGameDiv { text-align: center; }
    #duelSpeedCounters p { font-size: 18px; margin: 8px 0; }
    #duelSpeedClickButton {
      padding: 12px; font-size: 16px; border: none; border-radius: 6px;
      background: #7289da; color: #fff; cursor: pointer; transition: background 0.2s;
    }
    #duelSpeedClickButton:disabled { background: #ccc; cursor: not-allowed; }
    /* RPS Game UI */
    #rpsGameDiv { text-align: center; }
    #rpsChoices button {
      margin: 5px; padding: 10px 20px; font-size: 16px;
      border: none; border-radius: 6px; background: #7289da; color: #fff;
      cursor: pointer; transition: background 0.2s;
    }
    #rpsChoices button:hover { background: #677bc4; }
    #rpsResult { margin-top: 10px; font-size: 16px; font-weight: bold; }
    /* DARK MODE */
    body.dark-mode {
      background: #2f3136; color: #dcdcdc;
    }
    body.dark-mode #loginDiv,
    body.dark-mode #chatDiv,
    body.dark-mode #settingsDiv,
    body.dark-mode #duelSpeedGameDiv,
    body.dark-mode #rpsGameDiv {
      background: #36393f; color: #dcdcdc;
    }
    body.dark-mode textarea {
      background: #40444b; color: #dcdcdc; border: 1px solid #4f545c;
    }
    body.dark-mode button {
      background: #4f545c; color: #dcdcdc; border: 1px solid #4f545c;
    }
    body.dark-mode select {
      background: #40444b; color: #dcdcdc; border: 1px solid #4f545c;
    }
    /* FORM ELEMENTS */
    input[type="text"], textarea, select {
      width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #ccc;
      border-radius: 6px; font-size: 14px;
    }
    button {
      width: 100%; padding: 8px; border: none; border-radius: 6px;
      background: #7289da; color: #fff; font-size: 14px; cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #677bc4; }
    /* HEADERS & TEXT */
    h2, h3 { margin-bottom: 12px; font-weight: 600; }
    p { margin-bottom: 8px; font-size: 14px; }
    .tutorial-box {
      background: #fafafa; padding: 6px; border-radius: 4px; font-size: 13px;
      margin-bottom: 8px;
    }
    body.dark-mode .tutorial-box { background: #40444b; color: #dcdcdc; }
    /* CHAT MESSAGES */
    #messages {
      list-style: none; padding: 0; max-height: 300px; overflow-y: auto;
      margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px;
      background: #ffffff;
    }
    body.dark-mode #messages { background: #40444b; border-color: #4f545c; }
    #messages li {
      padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 14px;
    }
    #messages li:last-child { border-bottom: none; }
    .account-user { color: #7289da; font-weight: bold; }
    .anonymous-user { color: #333; }
    .broadcast-msg {
      background: #ffeb3b; color: #333; font-weight: bold;
      padding: 4px; border-radius: 4px;
    }
    /* TEXTAREA AUTO-RESIZE */
    textarea { resize: none; min-height: 40px; max-height: 120px; overflow-y: auto; }
    /* DM SECTION */
    #dmSection { margin-top: 10px; border-top: 1px solid #ccc; padding-top: 8px; }
    #dmMessages, #dm2Messages, #dm3Messages {
      list-style: none; padding: 0; max-height: 200px; overflow-y: auto;
      margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px;
      background: #ffffff;
    }
    body.dark-mode #dmMessages,
    body.dark-mode #dm2Messages,
    body.dark-mode #dm3Messages {
      background: #40444b; border-color: #4f545c;
    }
    #dmMessages li, #dm2Messages li, #dm3Messages li {
      padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 14px;
    }
    /* REWORKED MEMBERS LIST */
    #memberListContainer {
      background: #ffffff; 
      border: 1px solid #ddd; 
      border-radius: 6px; 
      padding: 10px; 
      margin-top: 10px;
    }
    #memberListHeader {
      margin-bottom: 8px; 
      font-size: 18px; 
      font-weight: bold;
    }
    #memberListSearch input {
      width: 100%;
      padding: 6px;
      margin-bottom: 10px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    #memberList {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    .member-item {
      display: flex;
      align-items: center;
      padding: 6px;
      border-bottom: 1px solid #eee;
      transition: background 0.2s;
    }
    .member-item:hover {
      background: #f0f0f0;
    }
    .member-avatar {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: #7289da;
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-right: 10px;
      font-weight: bold;
    }
    .member-name {
      font-size: 14px;
      color: #333;
    }
    /* Dark mode overrides for the members list */
    body.dark-mode #memberListContainer {
      background: #2f3136; 
      border: 1px solid #4f545c;
    }
    body.dark-mode #memberListSearch input {
      background: #40444b;
      color: #dcdcdc;
      border: 1px solid #4f545c;
    }
    body.dark-mode .member-item {
      border-bottom: 1px solid #4f545c;
    }
    body.dark-mode .member-item:hover {
      background: #36393f;
    }
    body.dark-mode .member-name {
      color: #dcdcdc;
    }
    /* MESSAGE ANIMATION */
    @keyframes message-enter {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .message-enter { animation: message-enter 0.3s ease forwards; }
    /* EXTRA SETTINGS HEADINGS */
    #settingsDiv h3 { margin-top: 16px; margin-bottom: 8px; font-weight: 600; }
    /* Hide audio elements */
    audio { display: none; }
    /* Changelog & Help Modal Overlays */
    #changelogOverlay, #helpModal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.7); display: none;
      justify-content: center; align-items: center; z-index: 9999;
      transition: opacity 0.3s ease;
    }
    #changelogModal, #helpModalContent {
      background: #fff; padding: 20px; border-radius: 10px;
      max-width: 400px; width: 90%; color: #000;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #changelogModal ul, #helpModalContent ul {
      margin: 10px 0; padding-left: 30px;
    }
    /* Custom Font Classes */
    .font-arial { font-family: Arial, sans-serif; }
    .font-georgia { font-family: Georgia, serif; }
    .font-courier { font-family: "Courier New", monospace; }
    .font-comic { font-family: "Comic Sans MS", cursive, sans-serif; }
    .font-roboto { font-family: Roboto, sans-serif; }
    .font-times { font-family: "Times New Roman", Times, serif; }
    .font-verdana { font-family: Verdana, sans-serif; }
    .font-trebuchet { font-family: "Trebuchet MS", sans-serif; }
    .font-lucida { font-family: "Lucida Sans Unicode", sans-serif; }
    .font-garamond { font-family: Garamond, serif; }
    .font-helvetica { font-family: Helvetica, sans-serif; }
    .font-tahoma { font-family: Tahoma, sans-serif; }
    .font-impact { font-family: Impact, sans-serif; }
    .font-futura { font-family: Futura, sans-serif; }
    .font-open-sans { font-family: "Open Sans", sans-serif; }
    .font-lato { font-family: Lato, sans-serif; }
    .font-montserrat { font-family: Montserrat, sans-serif; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Changelog Overlay -->
    <div id="changelogOverlay">
      <div id="changelogModal">
        <h2>Alpha v2.0.0 (Client Version 201)</h2>
        <ul>
          <li>Updated UI and layout.</li>
          <li>Added background music controls, sound notifications, and message timestamp toggles.</li>
          <li>Integrated Duel Speed and Rock–Paper–Scissors minigames.</li>
          <li>Now enforces client version 201 for all operations.</li>
        </ul>
        <button onclick="hideChangeLog()">Close</button>
      </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal">
      <div id="helpModalContent">
        <h2>Help &amp; Commands</h2>
        <ul>
          <li>/createroom [roomName] - Create a group chat room</li>
          <li>/join [roomName] - Join a group chat room</li>
          <li>/invite [accountName] - Invite someone to a group chat room</li>
          <li>/leave - Leave the current group chat room</li>
          <li>/duelspeed [account] - Challenge someone to a Duel Speed game</li>
          <li>/rps [account] - Challenge someone to a Rock–Paper–Scissors game</li>
          <li>/accept - Accept a pending challenge</li>
          <li>/decline - Decline a pending challenge</li>
          <span id="opHelp" style="display:none;">
            <li>/mute [username] - (OP Only) Mute a user</li>
            <li>/unmute [username] - (OP Only) Unmute a user</li>
            <li>/terminate [accountName] - (OP Only) Terminate an account</li>
          </span>
        </ul>
        <button onclick="hideHelpWindow()">Close</button>
      </div>
    </div>

    <!-- LOGIN SCREEN -->
    <div id="loginDiv">
      <h2>Enter Chat</h2>
      <p>Anonymous / Temporary Name:</p>
      <input type="text" id="anonymousInput" class="username-input" placeholder="Anonymous Name" />
      <button onclick="initiateChatSession()" class="enter-chat-btn">Start Chatting</button>
      <hr />
      <h3>Account</h3>
      <div id="notLoggedInUI">
        <input type="text" id="accNameInput" placeholder="Desired username" />
        <input type="text" id="accPassInput" placeholder="Password" />
        <button onclick="registerOrAccessAccount()">Create/Login Account</button>
      </div>
      <div id="loggedInUI" style="display:none;">
        <p>Logged in as: <span id="loggedInName"></span></p>
        <input type="text" id="renameInput" placeholder="New username" />
        <button onclick="changeUserName()">Rename Account</button>
        <br /><br />
        <input type="text" id="changePassInput" placeholder="New Password" />
        <button onclick="updateUserPassword()">Change Password</button>
        <br /><br />
        <button onclick="performAccountLogout()">Log Out</button>
      </div>
      <hr />
      <button onclick="openSettingsPage()">Settings</button>
      <!-- OP-ONLY Section -->
      <div id="opSection" style="display:none; margin-top: 10px; border-top:1px solid #ccc; padding-top:10px;">
        <h3>OP Tools</h3>
        <button onclick="securelyClearChatGlobal()">Clear Chat (Server-Side)</button>
        <br /><br />
        <label for="opBroadcastInput">Broadcast Message:</label>
        <input type="text" id="opBroadcastInput" />
        <button onclick="sendOpBroadcast()">Send Broadcast</button>
        <br /><br />
        <label for="opColorPicker">Change Your Name Color:</label>
        <input type="color" id="opColorPicker" value="#7289da" />
        <button onclick="setOpUserColor()">Set Name Color</button>
        <br /><br />
        <button onclick="securelyClearTypingGlobal()">Clear All 'Typing'</button>
        <br /><br />
        <label for="muteTarget">Mute User:</label>
        <input type="text" id="muteTarget" placeholder="Username to mute" />
        <button onclick="securelyMuteUser(document.getElementById('muteTarget').value.trim())">Mute User</button>
        <br /><br />
        <label for="unmuteTarget">Unmute User:</label>
        <input type="text" id="unmuteTarget" placeholder="Username to unmute" />
        <button onclick="securelyUnmuteUser(document.getElementById('unmuteTarget').value.trim())">Unmute User</button>
        <br /><br />
        <label for="terminateTarget">Terminate Account:</label>
        <input type="text" id="terminateTarget" placeholder="Account to terminate" />
        <button onclick="securelyTerminateAccount(document.getElementById('terminateTarget').value.trim())">Terminate Account</button>
        <br /><br />
        <!-- Button to clear the members list from the server -->
        <button onclick="clearMemberList()">Clear Member List</button>
      </div>
    </div>

    <!-- CHAT SCREEN -->
    <div id="chatDiv" style="display:none;">
      <h2>Yap Room</h2>
      <div class="tutorial-box">
        <strong>Group Chat Commands:</strong><br/>
        /createroom [roomName]<br/>
        /join [roomName]<br/>
        /invite [accountName]<br/>
        /leave<br/><br/>
        <strong>Duel Speed Command:</strong><br/>
        /duelspeed [account]<br/>
        (Then type /accept or /decline.)<br/><br/>
        <strong>Rock–Paper–Scissors Command:</strong><br/>
        /rps [account]<br/>
        (Then type /accept or /decline.)
      </div>
      <ul id="messages"></ul>
      <div id="typingStatus"></div>
      <div class="chat-controls">
        <textarea id="messageInput" placeholder="Type a message" oninput="processTypingIndicator()"></textarea>
        <button onclick="dispatchMessage()">Send</button>
        <button onclick="eraseChatDisplay()">Clear Chat</button>
      </div>
      <!-- DM Section -->
      <div id="dmSection">
        <h3>Direct Messages</h3>
        <div id="dmLoginWarning" style="color:red; display:none;">You must be logged in to use DMs.</div>
        <div id="dmUI" style="display:none;">
          <p><strong>DM #1</strong> – Type a username to DM:</p>
          <input type="text" id="dmTargetInput" placeholder="Username to DM" />
          <button onclick="launchDMChannel1()">Open DM</button>
          <div id="dmConversation" style="display:none; margin-top:10px;">
            <ul id="dmMessages"></ul>
            <div class="dm-controls">
              <textarea id="dmMessageInput" placeholder="Type a direct message" oninput="processTypingIndicator()"></textarea>
              <button onclick="transmitDMChannel1()">Send DM</button>
            </div>
          </div>
          <hr/>
          <p><strong>DM #2</strong> – Type a username to DM:</p>
          <input type="text" id="dm2TargetInput" placeholder="Username to DM" />
          <button onclick="launchDMChannel2()">Open DM #2</button>
          <div id="dm2Conversation" style="display:none; margin-top:10px;">
            <ul id="dm2Messages"></ul>
            <div class="dm-controls">
              <textarea id="dm2MessageInput" placeholder="Type a direct message" oninput="processTypingIndicator()"></textarea>
              <button onclick="transmitDMChannel2()">Send DM #2</button>
            </div>
          </div>
          <hr/>
          <p><strong>DM #3</strong> – Type a username to DM:</p>
          <input type="text" id="dm3TargetInput" placeholder="Username to DM" />
          <button onclick="launchDMChannel3()">Open DM #3</button>
          <div id="dm3Conversation" style="display:none; margin-top:10px;">
            <ul id="dm3Messages"></ul>
            <div class="dm-controls">
              <textarea id="dm3MessageInput" placeholder="Type a direct message" oninput="processTypingIndicator()"></textarea>
              <button onclick="transmitDMChannel3()">Send DM #3</button>
            </div>
          </div>
        </div>
      </div>
      <!-- REWORKED MEMBERS LIST -->
      <div id="memberListContainer">
        <h3 id="memberListHeader">Members Online</h3>
        <div id="memberListSearch">
          <input type="text" id="memberListFilter" placeholder="Filter members..." oninput="filterMemberList()" />
        </div>
        <ul id="memberList"></ul>
      </div>
      <div style="text-align:center; margin-top:10px;">
        <button onclick="goBackToMainScreen()">Return to Main Screen</button>
        <button onclick="displayHelpWindow()">Help</button>
      </div>
    </div>

    <!-- SETTINGS SCREEN -->
    <div id="settingsDiv" style="display:none;">
      <h2>Settings</h2>
      <label>
        <input type="checkbox" id="themeToggle" onchange="switchDarkMode()" />
        Dark Mode
      </label>
      <br/><br/>
      <label for="guiSizeRange">GUI Size</label>
      <input type="range" id="guiSizeRange" min="0.5" max="2.0" step="0.1" value="1.0" onchange="adjustGuiScaling()" />
      <p id="guiSizeValue"></p>
      <label for="fontSelect">Choose Font:</label>
      <select id="fontSelect" onchange="changeUIFont()">
        <option value="font-arial">Arial</option>
        <option value="font-georgia">Georgia</option>
        <option value="font-courier">Courier New</option>
        <option value="font-comic">Comic Sans MS</option>
        <option value="font-roboto">Roboto</option>
        <option value="font-times">Times New Roman</option>
        <option value="font-verdana">Verdana</option>
        <option value="font-trebuchet">Trebuchet MS</option>
        <option value="font-lucida">Lucida Sans Unicode</option>
        <option value="font-garamond">Garamond</option>
        <option value="font-helvetica">Helvetica</option>
        <option value="font-tahoma">Tahoma</option>
        <option value="font-impact">Impact</option>
        <option value="font-futura">Futura</option>
        <option value="font-open-sans">Open Sans</option>
        <option value="font-lato">Lato</option>
        <option value="font-montserrat">Montserrat</option>
      </select>
      <br/><br/>
      <label>
        <input type="checkbox" id="notificationsToggle" onchange="switchDesktopNotifications()" />
        Enable Desktop Notifications
      </label>
      <br/><br/>
      <h3>Background Music</h3>
      <label for="musicFileInput">Upload Music:</label>
      <input type="file" id="musicFileInput" accept="audio/*" />
      <br/>
      <button onclick="switchBackgroundMusic()">Play/Pause Music</button>
      <label>Volume:</label>
      <input type="range" id="musicVolume" min="0" max="1" step="0.01" value="1" onchange="modifyMusicVolume()" />
      <button onclick="removeBackgroundMusic()">Remove Music</button>
      <br/><br/>
      <h3>Sound Notifications</h3>
      <label>
        <input type="checkbox" id="soundToggle" onchange="switchSoundAlerts()" />
        Enable Chat Sound Notifications
      </label>
      <br/>
      <label for="soundVolume">Sound Volume:</label>
      <input type="range" id="soundVolume" min="0" max="1" step="0.01" value="1" onchange="modifySoundVolume()" />
      <br/><br/>
      <h3>Message Timestamps</h3>
      <label>
        <input type="checkbox" id="timestampToggle" onchange="switchTimestampDisplay()" />
        Show Message Timestamps (hover to view)
      </label>
      <br/><br/>
      <button onclick="returnToSettingsOrLogin()">Back</button>
    </div>
    
    <!-- DUEL SPEED GAME UI -->
    <div id="duelSpeedGameDiv" style="display:none;">
      <h2>Duel Speed</h2>
      <div id="duelSpeedStatus">Get Ready...</div>
      <div id="duelSpeedCounters">
        <p id="player1Counter"></p>
        <p id="player2Counter"></p>
      </div>
      <button id="duelSpeedClickButton" onclick="recordDuelSpeedClick()">Click Me!</button>
    </div>

    <!-- ROCK-PAPER-SCISSORS GAME UI -->
    <div id="rpsGameDiv" style="display:none;">
      <h2>Rock–Paper–Scissors</h2>
      <div id="rpsStatus">Make your choice:</div>
      <div id="rpsChoices">
        <button onclick="selectRPSOption('rock')">Rock ✊</button>
        <button onclick="selectRPSOption('paper')">Paper ✋</button>
        <button onclick="selectRPSOption('scissors')">Scissors ✌️</button>
      </div>
      <div id="rpsResult"></div>
      <button id="rpsPlayAgainButton" style="display:none;" onclick="restartRPSMatch()">Play Again</button>
    </div>
  </div>

  <!-- Hidden Audio Elements -->
  <audio id="bgMusic" loop></audio>
  <audio id="chatSound" src="https://www.soundjay.com/button/beep-07.wav" preload="auto"></audio>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-database-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>

  <script>
    // Set required client version
    const NEW_CLIENT_VERSION = 201;

    /* =====================================================
       Firebase Configuration & Initialization
       ===================================================== */
    const newFirebaseConfig = {
      apiKey: "AIzaSyBkm5Lf3PaghllqcatG_FymhTm_x7mGa28",
      authDomain: "yaproom-14cfe.firebaseapp.com",
      databaseURL: "https://yaproom-14cfe-default-rtdb.firebaseio.com",
      projectId: "yaproom-14cfe",
      storageBucket: "yaproom-14cfe",
      messagingSenderId: "5332542311",
      appId: "1:5332542311:web:f1a1ab2fb81bf62b0b45c2"
    };
    firebase.initializeApp(newFirebaseConfig);
    const newDB = firebase.database();

    // New Firebase database key names
    const NEW_KEYS = {
      accounts: "accts_new",
      typing: "typing_new",
      messages: "msgs_new",
      groupRooms: "group_rooms_new",
      dms: "dms_new",
      broadcasts: "bcasts_new",
      presence: "activeUsers_new",
      opCommandChecks: "opCmdAuth_new",
      duelSpeedChallenges: "duelSpeedContests_new",
      rpsChallenges: "rpsContests_new",
      duelSpeedGames: "matches_new/duel_speed_new",
      rpsGames: "matches_new/rps_new",
      accountColors: "acctColors_new",
      mutedUsers: "mutedUsers_new"
    };

    /* =====================================================
       Global Variables & OP List
       ===================================================== */
    let opList = {}; // will be loaded from Firebase (node: "opList")
    let lastMsgTimestamp = 2000;
    const RATE_LIMIT = 2000;
    const forbiddenWords = ["shit","fuck","bitch","nigga","fucking","shitting","negro","bullshit","pussy"];
    let currentUser = null;
    let currentUserPassHash = null;
    let accountRemovalListener = null;
    let renamingFlag = false;
    let currentDMChannel = null, dmListener1 = null;
    let currentDMChannel2 = null, dmListener2 = null;
    let currentDMChannel3 = null, dmListener3 = null;
    let inGroupChatMode = false, activeGroupRoom = null, groupRoomListener = null;
    let typingTimer = null;
    let mutedList = {};
    let userColors = {};
    let publicMsgs = [];
    let publicListenerAddNew = null, publicListenerRemoveNew = null;
    let userPresenceRef = null;
    // Duel Speed variables
    let pendingDuelContest = null;
    let acceptedDuelContest = null;
    let duelGameID = null;
    let isDuelHost = false;
    let duelGameRef = null;
    let duelCountdownInterval = null;
    // RPS variables
    let pendingRPSContest = null;
    let acceptedRPSContest = null;
    let rpsGameID = null;
    let isRPSHost = false;
    let rpsGameRef = null;
    let rpsPlayerOne = "";
    let rpsPlayerTwo = "";
    let rpsGameEndTimer = null;

    // Unique client ID for op commands
    let clientIdentifier = localStorage.getItem("clientID");
    if (!clientIdentifier) {
      clientIdentifier = Math.random().toString(36).substring(2) + Date.now().toString(36);
      localStorage.setItem("clientID", clientIdentifier);
    }

    // Fetch the op list from Firebase (assumed to be stored at node "opList")
    function fetchOpList() {
      newDB.ref("opList").once("value")
        .then(function(snapshot) {
          opList = snapshot.val() || {};
        })
        .catch(function(error) {
          console.error("Error fetching op list:", error);
        });
    }

    function isUserOP() {
      return currentUser && opList[currentUser.toLowerCase()] === true;
    }

    function refreshOpSectionVisibility() {
      const opSec = document.getElementById("opSection");
      if (opSec) { opSec.style.display = isUserOP() ? "block" : "none"; }
    }

    function verifyOpCommandAuthorization(callback) {
      if (!currentUser) { callback(false); return; }
      const opCheckRef = newDB.ref(NEW_KEYS.opCommandChecks + "/" + currentUser);
      const checkPayload = { clientID: clientIdentifier, timestamp: firebase.database.ServerValue.TIMESTAMP };
      opCheckRef.set(checkPayload, (err) => {
         if (err) { alert("Error in op authorization check."); callback(false); }
         else {
           opCheckRef.once("value", (snap) => {
             const data = snap.val();
             if (data && data.clientID === clientIdentifier) { callback(true); }
             else { callback(false); }
           });
         }
      });
    }

    (function(){
      async function terminateUserAccount(target, valid) {
        if (!valid) { alert("Direct terminate disabled. Use securelyTerminateAccount."); return; }
        if (!isUserOP() && target === currentUser) {
          alert("Unauthorized op command. Your account will be terminated.");
        }
        try {
          await newDB.ref(NEW_KEYS.accounts + "/" + target).remove();
          await newDB.ref(NEW_KEYS.accountColors + "/" + target).remove();
          await newDB.ref(NEW_KEYS.typing + "/" + target).remove();
          await newDB.ref(NEW_KEYS.mutedUsers + "/" + target).remove();
          const snapMsgs = await newDB.ref(NEW_KEYS.messages).once("value");
          snapMsgs.forEach((child) => {
            const val = child.val();
            if (val.user && val.user === target) { child.ref.remove(); }
          });
          alert(`Account "${target}" has been TERMINATED.`);
          if (target === currentUser) { performAccountLogout(); }
        } catch(e) { alert("Error terminating account: " + e); }
      }
      function securelyTerminateAccount(target) {
        verifyOpCommandAuthorization(function(valid){
          if (valid) { terminateUserAccount(target, true); }
          else { alert("Op authorization failed. Command voided."); }
        });
      }
      function muteUser(target, valid) {
        if (!valid) { alert("Direct mute disabled. Use securelyMuteUser."); return; }
        newDB.ref(NEW_KEYS.mutedUsers + "/" + target).set({ value: true, op: currentUser, clientVersion: NEW_CLIENT_VERSION });
        alert(`User "${target}" has been muted.`);
      }
      function securelyMuteUser(target) {
        verifyOpCommandAuthorization(function(valid){
          if (valid) { muteUser(target, true); }
          else { alert("Op authorization failed. Command voided."); }
        });
      }
      function unmuteUser(target, valid) {
        if (!valid) { alert("Direct unmute disabled. Use securelyUnmuteUser."); return; }
        newDB.ref(NEW_KEYS.mutedUsers + "/" + target).remove();
        alert(`User "${target}" has been unmuted.`);
      }
      function securelyUnmuteUser(target) {
        verifyOpCommandAuthorization(function(valid){
          if (valid) { unmuteUser(target, true); }
          else { alert("Op authorization failed. Command voided."); }
        });
      }
      async function clearGlobalChat(valid) {
        if (!valid) { alert("Direct clear chat disabled. Use securelyClearChatGlobal."); return; }
        await newDB.ref(NEW_KEYS.messages).remove();
        await newDB.ref(NEW_KEYS.broadcasts).remove();
        document.getElementById("messages").innerHTML = "";
        publicMsgs = [];
        alert("All messages and broadcasts cleared for everyone.");
      }
      function securelyClearChatGlobal() {
        verifyOpCommandAuthorization(function(valid){
          if (valid) { clearGlobalChat(true); }
          else { alert("Op authorization failed. Command voided."); }
        });
      }
      function clearGlobalTyping(valid) {
        if (!valid) { alert("Direct clear typing disabled. Use securelyClearTypingGlobal."); return; }
        newDB.ref(NEW_KEYS.typing).remove();
        alert("All typing statuses have been cleared for everyone.");
      }
      function securelyClearTypingGlobal() {
        verifyOpCommandAuthorization(function(valid){
          if (valid) { clearGlobalTyping(true); }
          else { alert("Op authorization failed. Command voided."); }
        });
      }
      window.securelyTerminateAccount = securelyTerminateAccount;
      window.securelyMuteUser = securelyMuteUser;
      window.securelyUnmuteUser = securelyUnmuteUser;
      window.securelyClearChatGlobal = securelyClearChatGlobal;
      window.securelyClearTypingGlobal = securelyClearTypingGlobal;
      window.setOpUserColor = function() {
        verifyOpCommandAuthorization(function(valid){
          if (!valid) { alert("Op authorization failed. Command voided."); return; }
          const colorPicker = document.getElementById("opColorPicker");
          const chosenColor = colorPicker.value;
          newDB.ref(NEW_KEYS.accountColors + "/" + currentUser).set(chosenColor);
          alert("Your chat color has been updated to: " + chosenColor);
        });
      };
    })();

    function initializeTextAreaShortcuts(textAreaId, sendCallback) {
      const ta = document.getElementById(textAreaId);
      ta.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) { e.preventDefault(); sendCallback(); }
      });
      ta.addEventListener("input", adjustTextareaHeight);
    }

    function adjustTextareaHeight(e) {
      const ta = e.target;
      ta.style.height = "auto";
      ta.style.height = (ta.scrollHeight) + "px";
    }

    function activatePublicChatListeners() {
      newDB.ref(NEW_KEYS.messages).off("child_added", publicListenerAddNew);
      newDB.ref(NEW_KEYS.messages).off("child_removed", publicListenerRemoveNew);
      publicMsgs = [];
      document.getElementById("messages").innerHTML = "";
      publicListenerAddNew = newDB.ref(NEW_KEYS.messages).on("child_added", (snap) => {
        const msg = snap.val();
        const key = snap.key;
        if (msg.user && mutedList[msg.user]) return;
        publicMsgs.push({ key, ...msg });
        if (!inGroupChatMode) { renderChatMessage(msg.user, msg.text, msg.isAccount, false, key, msg.timestamp); }
        if (msg.user && msg.text) { verifyMentionsAndAlert(msg.user, msg.text); }
      });
      publicListenerRemoveNew = newDB.ref(NEW_KEYS.messages).on("child_removed", (snap) => {
        const remKey = snap.key;
        publicMsgs = publicMsgs.filter(m => m.key !== remKey);
        const li = document.querySelector(`li[data-key="${remKey}"]`);
        if (li) li.remove();
      });
    }

    function verifyMentionsAndAlert(sender, text) {
      if (!currentUser || !text) return;
      const lowerText = text.toLowerCase();
      const mentionStr = "@" + currentUser.toLowerCase();
      if (lowerText.includes(mentionStr) && sender !== currentUser) {
        displayMentionAlert(sender, text);
      }
    }

    function displayMentionAlert(sender, text) {
      const notifOn = localStorage.getItem("notificationsEnabled") === "true";
      if (!("Notification" in window) || !notifOn) return;
      if (document.hidden && Notification.permission === "granted") {
        new Notification("You were mentioned by " + sender, {
          body: text,
          icon: "https://via.placeholder.com/50"
        });
      }
    }

    async function registerOrAccessAccount() {
      let desiredName = document.getElementById("accNameInput").value.trim();
      const desiredPass = document.getElementById("accPassInput").value.trim();
      if (!desiredName || !desiredPass) { alert("Please provide both a username and a password."); return; }
      if (/\s/.test(desiredName)) { alert("Usernames cannot contain spaces."); return; }
      const passHash = sha256(desiredPass);
      try {
        const snap = await newDB.ref(NEW_KEYS.accounts + "/" + desiredName).once("value");
        if (!snap.exists()) {
          await newDB.ref(NEW_KEYS.accounts + "/" + desiredName).set({
            passwordHash: passHash,
            createdAt: Date.now(),
            clientVersion: NEW_CLIENT_VERSION
          });
          alert("Account created! Logged in as: " + desiredName);
        } else {
          const data = snap.val();
          if (data.passwordHash !== passHash) { alert("Incorrect password or name is taken by someone else."); return; }
          alert("Logged in successfully as: " + desiredName);
        }
        currentUser = desiredName;
        currentUserPassHash = passHash;
        localStorage.setItem("acc_username", currentUser);
        localStorage.setItem("acc_passHash", currentUserPassHash);
        refreshAccountInterface();
      } catch(e) { alert("Error during account access: " + e); }
    }

    function refreshAccountInterface() {
      const notLogged = document.getElementById("notLoggedInUI");
      const loggedIn = document.getElementById("loggedInUI");
      const loggedNameSpan = document.getElementById("loggedInName");
      const anonInputField = document.getElementById("anonymousInput");
      if (currentUser && currentUserPassHash) {
        notLogged.style.display = "none";
        loggedIn.style.display = "block";
        loggedNameSpan.textContent = currentUser;
        anonInputField.value = currentUser;
        anonInputField.disabled = true;
        monitorAccountRemoval();
        monitorDuelSpeedContests();
        monitorRPSContests();
      } else {
        notLogged.style.display = "block";
        loggedIn.style.display = "none";
        anonInputField.value = "";
        anonInputField.disabled = false;
        if (accountRemovalListener) { accountRemovalListener.off("value"); accountRemovalListener = null; }
      }
      refreshDMInterface();
      refreshOpSectionVisibility();
    }

    function monitorAccountRemoval() {
      if (accountRemovalListener) { accountRemovalListener.off("value"); accountRemovalListener = null; }
      if (!currentUser) return;
      accountRemovalListener = newDB.ref(NEW_KEYS.accounts + "/" + currentUser);
      accountRemovalListener.on("value", (snap) => {
        if (!snap.exists() && !renamingFlag) {
          alert("Your account has been terminated!");
          performAccountLogout();
        }
      });
    }

    async function performAccountLogout() {
      clearUserTypingStatus();
      if (accountRemovalListener) { accountRemovalListener.off("value"); accountRemovalListener = null; }
      if (userPresenceRef) { userPresenceRef.remove(); userPresenceRef = null; }
      localStorage.removeItem("acc_username");
      localStorage.removeItem("acc_passHash");
      currentUser = null;
      currentUserPassHash = null;
      alert("Logged out.");
      refreshAccountInterface();
    }

    function clearUserTypingStatus() {
      if (currentUser) { newDB.ref(NEW_KEYS.typing + "/" + currentUser).remove(); }
    }

    async function changeUserName() {
      if (!currentUser || !currentUserPassHash) { alert("Not logged in, cannot rename."); return; }
      const newName = document.getElementById("renameInput").value.trim();
      if (!newName) { alert("Enter a new username."); return; }
      if (/\s/.test(newName)) { alert("Usernames cannot contain spaces!"); return; }
      const snap = await newDB.ref(NEW_KEYS.accounts + "/" + currentUser).once("value");
      if (!snap.exists()) { alert("Your account no longer exists."); return; }
      const currentData = snap.val();
      const lastRename = currentData.lastRenamed || 0;
      const now = Date.now();
      const TWELVE_HOURS = 12 * 60 * 60 * 1000;
      if (now - lastRename < TWELVE_HOURS) {
        const hrsLeft = Math.ceil((TWELVE_HOURS - (now - lastRename)) / (1000 * 60 * 60));
        alert(`Wait ${hrsLeft} more hour(s) before renaming again!`);
        return;
      }
      const newSnap = await newDB.ref(NEW_KEYS.accounts + "/" + newName).once("value");
      if (newSnap.exists()) { alert("That username is taken."); return; }
      try {
        renamingFlag = true;
        await newDB.ref(NEW_KEYS.accounts + "/" + currentUser).remove();
        await newDB.ref(NEW_KEYS.accounts + "/" + newName).set({
          passwordHash: currentUserPassHash,
          createdAt: currentData.createdAt,
          lastRenamed: now,
          clientVersion: NEW_CLIENT_VERSION
        });
        newDB.ref(NEW_KEYS.typing + "/" + currentUser).remove();
        currentUser = newName;
        localStorage.setItem("acc_username", currentUser);
        if (userPresenceRef) { userPresenceRef.update({ username: newName }); }
        alert("Renamed to " + newName);
        renamingFlag = false;
        refreshAccountInterface();
      } catch(e) { renamingFlag = false; alert("Error renaming: " + e); }
    }

    async function updateUserPassword() {
      if (!currentUser || !currentUserPassHash) { alert("Not logged in, cannot change password."); return; }
      const newPass = document.getElementById("changePassInput").value.trim();
      if (!newPass) { alert("Enter a new password."); return; }
      const newHash = sha256(newPass);
      try {
        await newDB.ref(NEW_KEYS.accounts + "/" + currentUser).update({
          passwordHash: newHash,
          clientVersion: NEW_CLIENT_VERSION
        });
        currentUserPassHash = newHash;
        localStorage.setItem("acc_passHash", newHash);
        alert("Password changed successfully!");
        document.getElementById("changePassInput").value = "";
      } catch(e) { alert("Error changing password: " + e); }
    }

    function initiateChatSession() {
      if (!currentUser) {
        const anonName = document.getElementById("anonymousInput").value.trim();
        if (!anonName) { alert("Enter a name or create an account."); return; }
        if (/\s/.test(anonName)) { alert("Usernames cannot contain spaces."); return; }
        currentUser = anonName;
      }
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("chatDiv").style.display = "block";
      document.getElementById("messageInput").focus();
      refreshDMInterface();
      initializeUserPresence(); // Set up your presence when entering chat.
    }

    function goBackToMainScreen() {
      clearUserTypingStatus();
      if (userPresenceRef) { userPresenceRef.remove(); userPresenceRef = null; }
      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
      refreshOpSectionVisibility();
    }

    function filterForbiddenWords(text) {
      let filteredText = text;
      forbiddenWords.forEach(word => {
        const regex = new RegExp("\\b" + word + "\\b", "gi");
        filteredText = filteredText.replace(regex, "****");
      });
      return filteredText;
    }

    function dispatchMessage() {
      const inp = document.getElementById("messageInput");
      let text = inp.value.trim();
      if (!text) return;
      if (text.startsWith("/")) {
        processCommandInput(text);
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const nowTime = Date.now();
      if (nowTime - lastMsgTimestamp < RATE_LIMIT) {
        const secRemain = Math.ceil((RATE_LIMIT - (nowTime - lastMsgTimestamp)) / 1000);
        alert(`Wait ${secRemain} second(s).`);
        return;
      }
      if (currentUser && mutedList[currentUser]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      text = filterForbiddenWords(text);
      let finalName = currentUser || "Unknown";
      const isAcc = (currentUser && currentUserPassHash);
      if (inGroupChatMode && activeGroupRoom) {
        newDB.ref(NEW_KEYS.groupRooms + "/" + activeGroupRoom + "/messages").push({
          user: finalName,
          text: text,
          timestamp: firebase.database.ServerValue.TIMESTAMP,
          clientVersion: NEW_CLIENT_VERSION
        });
      } else {
        newDB.ref(NEW_KEYS.messages).push({
          user: finalName,
          text: text,
          isAccount: isAcc,
          timestamp: firebase.database.ServerValue.TIMESTAMP,
          clientVersion: NEW_CLIENT_VERSION
        });
      }
      inp.value = "";
      inp.style.height = "40px";
      lastMsgTimestamp = nowTime;
      if (currentUser) { newDB.ref(NEW_KEYS.typing + "/" + currentUser).remove(); }
    }

    function renderChatMessage(user, text, isAccount, isBroadcast, msgKey, timestamp) {
      const ul = document.getElementById("messages");
      const li = document.createElement("li");
      li.classList.add("message-enter");
      if (msgKey) { li.setAttribute("data-key", msgKey); }
      let userColorClass = isAccount ? "account-user" : "anonymous-user";
      let colorStyle = "";
      if (userColors[user]) { colorStyle = `style="color:${userColors[user]}; font-weight:bold;"`; }
      else if (isAccount) { colorStyle = `style="color:#7289da;"`; }
      if (isBroadcast) {
        li.innerHTML = `<span class="broadcast-msg">[BROADCAST from ${user}]</span> ${text}`;
      } else {
        li.innerHTML = `<span class="${userColorClass}" ${colorStyle}>${user}</span>: ${text}`;
      }
      if (localStorage.getItem("showTimestamps") === "true" && timestamp) {
        const dateObj = new Date(timestamp);
        li.title = dateObj.toLocaleString();
      }
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function eraseChatDisplay() {
      if (confirm("Are you sure you want to clear the chat messages on your screen?")) {
        document.getElementById("messages").innerHTML = "";
      }
    }

    function processTypingIndicator() {
      if (!currentUser) return;
      newDB.ref(NEW_KEYS.typing + "/" + currentUser).set(true, function() {
        newDB.ref(NEW_KEYS.typing + "/" + currentUser).update({ clientVersion: NEW_CLIENT_VERSION });
      });
      if (typingTimer) clearTimeout(typingTimer);
      typingTimer = setTimeout(() => { newDB.ref(NEW_KEYS.typing + "/" + currentUser).remove(); }, 3000);
    }

    function presentTypingStatus(typingObj) {
      const others = Object.keys(typingObj).filter(u => u !== currentUser);
      const typingDiv = document.getElementById("typingStatus");
      if (others.length === 0) { typingDiv.textContent = ""; }
      else if (others.length === 1) { typingDiv.textContent = `${others[0]} is typing...`; }
      else { typingDiv.textContent = `${others.join(", ")} are typing...`; }
    }

    function refreshDMInterface() {
      const warn = document.getElementById("dmLoginWarning");
      const dmUI = document.getElementById("dmUI");
      if (currentUser && currentUserPassHash) { warn.style.display = "none"; dmUI.style.display = "block"; }
      else { warn.style.display = "block"; dmUI.style.display = "none"; }
    }

    function launchDMChannel1() {
      const target = document.getElementById("dmTargetInput").value.trim();
      if (!target) { alert("Please type a username to DM."); return; }
      if (!currentUser || !currentUserPassHash) { alert("You must be logged in to DM."); return; }
      if (dmListener1 && currentDMChannel) { newDB.ref(currentDMChannel).off("child_added", dmListener1); }
      const userA = currentUser;
      const userB = target;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDMChannel = NEW_KEYS.dms + "/" + dmKey;
      document.getElementById("dmMessages").innerHTML = "";
      document.getElementById("dmConversation").style.display = "block";
      document.getElementById("dmMessageInput").focus();
      dmListener1 = newDB.ref(currentDMChannel).on("child_added", (snap) => {
        const val = snap.val();
        renderDMChannel1Message(val.user, val.text);
        if (val.user !== currentUser) {
          displayDMAlert(val.user, val.text);
          triggerSoundAlert();
        }
      });
    }

    function renderDMChannel1Message(sender, text) {
      const ul = document.getElementById("dmMessages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function transmitDMChannel1() {
      if (!currentDMChannel) { alert("No DM open. Type a username and 'Open DM' first."); return; }
      const inp = document.getElementById("dmMessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterForbiddenWords(text);
      if (currentUser && mutedList[currentUser]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUser || "Unknown";
      newDB.ref(currentDMChannel).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        clientVersion: NEW_CLIENT_VERSION
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    function launchDMChannel2() {
      const target = document.getElementById("dm2TargetInput").value.trim();
      if (!target) { alert("Please type a username to DM (DM #2)."); return; }
      if (!currentUser || !currentUserPassHash) { alert("You must be logged in to DM."); return; }
      if (dmListener2 && currentDMChannel2) { newDB.ref(currentDMChannel2).off("child_added", dmListener2); }
      const userA = currentUser;
      const userB = target;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDMChannel2 = NEW_KEYS.dms + "/" + dmKey;
      document.getElementById("dm2Messages").innerHTML = "";
      document.getElementById("dm2Conversation").style.display = "block";
      document.getElementById("dm2MessageInput").focus();
      dmListener2 = newDB.ref(currentDMChannel2).on("child_added", (snap) => {
        const val = snap.val();
        renderDMChannel2Message(val.user, val.text);
        if (val.user !== currentUser) {
          displayDMAlert(val.user, val.text);
          triggerSoundAlert();
        }
      });
    }

    function renderDMChannel2Message(sender, text) {
      const ul = document.getElementById("dm2Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function transmitDMChannel2() {
      if (!currentDMChannel2) { alert("No DM #2 open. Type a username and 'Open DM #2' first."); return; }
      const inp = document.getElementById("dm2MessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterForbiddenWords(text);
      if (currentUser && mutedList[currentUser]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUser || "Unknown";
      newDB.ref(currentDMChannel2).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        clientVersion: NEW_CLIENT_VERSION
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    function launchDMChannel3() {
      const target = document.getElementById("dm3TargetInput").value.trim();
      if (!target) { alert("Please type a username to DM (DM #3)."); return; }
      if (!currentUser || !currentUserPassHash) { alert("You must be logged in to DM."); return; }
      if (dmListener3 && currentDMChannel3) { newDB.ref(currentDMChannel3).off("child_added", dmListener3); }
      const userA = currentUser;
      const userB = target;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDMChannel3 = NEW_KEYS.dms + "/" + dmKey;
      document.getElementById("dm3Messages").innerHTML = "";
      document.getElementById("dm3Conversation").style.display = "block";
      document.getElementById("dm3MessageInput").focus();
      dmListener3 = newDB.ref(currentDMChannel3).on("child_added", (snap) => {
        const val = snap.val();
        renderDMChannel3Message(val.user, val.text);
        if (val.user !== currentUser) {
          displayDMAlert(val.user, val.text);
          triggerSoundAlert();
        }
      });
    }

    function renderDMChannel3Message(sender, text) {
      const ul = document.getElementById("dm3Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function transmitDMChannel3() {
      if (!currentDMChannel3) { alert("No DM #3 open. Type a username and 'Open DM' first."); return; }
      const inp = document.getElementById("dm3MessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterForbiddenWords(text);
      if (currentUser && mutedList[currentUser]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUser || "Unknown";
      newDB.ref(currentDMChannel3).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP,
        clientVersion: NEW_CLIENT_VERSION
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    async function processCommandInput(inputText) {
      const parts = inputText.split(" ");
      const command = parts[0].toLowerCase();
      const argument = parts[1] ? parts[1].trim() : null;
      if (command === "/mute" || command === "/unmute" || command === "/terminate") {
        if (!isUserOP()) {
          alert("Unauthorized op command detected. Your account will be terminated.");
          securelyTerminateAccount(currentUser);
          return;
        }
        if (command === "/mute") { securelyMuteUser(argument); return; }
        else if (command === "/unmute") { securelyUnmuteUser(argument); return; }
        else if (command === "/terminate") { if (!argument) { alert("Usage: /terminate [accountName]"); } else { securelyTerminateAccount(argument); } return; }
      }
      if (command === "/duelspeed") {
         if (!argument) { alert("Usage: /duelspeed [account]"); return; }
         startDuelSpeedContest(argument);
         return;
      }
      if (command === "/rps") {
         if (!argument) { alert("Usage: /rps [account]"); return; }
         startRPSContest(argument);
         return;
      }
      if (command === "/accept") {
         if (pendingDuelContest) { approveDuelSpeedContest(); return; }
         else if (pendingRPSContest) { approveRPSContest(); return; }
         else { alert("No pending challenge to accept."); }
      }
      if (command === "/decline") {
         if (pendingDuelContest) { rejectDuelSpeedContest(); return; }
         else if (pendingRPSContest) { rejectRPSContest(); return; }
         else { alert("No pending challenge to decline."); }
      }
      switch(command) {
        case "/createroom":
          if (!argument) { alert("Usage: /createroom [roomName]"); return; }
          await createGroupRoom(argument);
          break;
        case "/join":
          if (!argument) { alert("Usage: /join [roomName]"); return; }
          await joinGroupRoom(argument);
          break;
        case "/invite":
          if (!argument) { alert("Usage: /invite [accountName]"); return; }
          await inviteToGroupRoom(argument);
          break;
        case "/leave":
          leaveGroupRoom();
          break;
        default:
          alert("Unknown command.");
      }
    }

    function startDuelSpeedContest(targetUser) {
      if (!currentUser) { alert("Login required to challenge."); return; }
      if (targetUser.toLowerCase() === currentUser.toLowerCase()) { alert("Cannot challenge yourself!"); return; }
      let gameID = newDB.ref(NEW_KEYS.duelSpeedGames).push().key;
      let contestData = {
         challenger: currentUser,
         challenged: targetUser,
         status: "pending",
         gameId: gameID,
         timestamp: firebase.database.ServerValue.TIMESTAMP,
         clientVersion: NEW_CLIENT_VERSION
      };
      newDB.ref(NEW_KEYS.duelSpeedChallenges + "/" + gameID).set(contestData);
      alert("Duel Speed challenge sent to " + targetUser + "!");
    }

    function monitorDuelSpeedContests() {
      newDB.ref(NEW_KEYS.duelSpeedChallenges).on("child_added", function(snap) {
         let contest = snap.val();
         if (contest.challenged.toLowerCase() === currentUser.toLowerCase() && contest.status === "pending") {
            if (!pendingDuelContest) {
              pendingDuelContest = contest;
              alert(contest.challenger + " has challenged you to Duel Speed! Type /accept to accept or /decline to decline.");
            }
         }
      });
      newDB.ref(NEW_KEYS.duelSpeedChallenges).on("child_changed", function(snap) {
         let contest = snap.val();
         if (contest.challenged.toLowerCase() === currentUser.toLowerCase() && contest.status === "pending") {
            if (!pendingDuelContest) {
              pendingDuelContest = contest;
              alert(contest.challenger + " has challenged you to Duel Speed! Type /accept to accept or /decline to decline.");
            }
         }
         if (contest.challenger.toLowerCase() === currentUser.toLowerCase() && contest.status === "accepted") {
            acceptedDuelContest = contest;
            beginDuelSpeedMatch(contest.gameId, contest.challenger, contest.challenged);
         }
      });
    }

    function approveDuelSpeedContest() {
      if (!pendingDuelContest) { alert("No pending Duel Speed challenge."); return; }
      let gameID = pendingDuelContest.gameId;
      newDB.ref(NEW_KEYS.duelSpeedChallenges + "/" + gameID).update({ status: "accepted", clientVersion: NEW_CLIENT_VERSION });
      beginDuelSpeedMatch(gameID, pendingDuelContest.challenger, pendingDuelContest.challenged);
      pendingDuelContest = null;
    }

    function rejectDuelSpeedContest() {
      if (!pendingDuelContest) { alert("No pending Duel Speed challenge."); return; }
      let gameID = pendingDuelContest.gameId;
      newDB.ref(NEW_KEYS.duelSpeedChallenges + "/" + gameID).remove();
      pendingDuelContest = null;
      alert("Duel Speed challenge declined.");
    }

    function beginDuelSpeedMatch(gameID, playerOne, playerTwo) {
      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("duelSpeedGameDiv").style.display = "block";
      duelGameID = gameID;
      duelGameRef = newDB.ref(NEW_KEYS.duelSpeedGames + "/" + gameID);
      duelGameRef.once("value", function(snap) {
         if (!snap.exists()) {
            duelGameRef.set({
               players: {
                   [playerOne]: { clicks: 0 },
                   [playerTwo]: { clicks: 0 }
               },
               status: "countdown",
               countdown: 3,
               clientVersion: NEW_CLIENT_VERSION
            });
         }
         initializeDuelSpeedMatch(gameID, playerOne, playerTwo);
      });
      newDB.ref(NEW_KEYS.duelSpeedChallenges + "/" + gameID).remove();
    }

    function initializeDuelSpeedMatch(gameID, playerOne, playerTwo) {
      isDuelHost = (currentUser.toLowerCase() === playerOne.toLowerCase());
      duelGameRef.on("value", function(snap) {
         let gameData = snap.val();
         if (!gameData) return;
         if (gameData.status === "countdown") {
            document.getElementById("duelSpeedStatus").textContent = "Starting in " + gameData.countdown + "...";
            document.getElementById("duelSpeedClickButton").disabled = true;
         } else if (gameData.status === "playing") {
            document.getElementById("duelSpeedStatus").textContent = "Go!";
            document.getElementById("duelSpeedClickButton").disabled = false;
         } else if (gameData.status === "ended") {
            document.getElementById("duelSpeedStatus").textContent = gameData.winner + " wins!";
            document.getElementById("duelSpeedClickButton").disabled = true;
            setTimeout(() => {
              document.getElementById("duelSpeedGameDiv").style.display = "none";
              document.getElementById("chatDiv").style.display = "block";
              document.getElementById("messageInput").focus();
            }, 3000);
         }
         document.getElementById("player1Counter").textContent = playerOne + ": " + (gameData.players[playerOne].clicks || 0) + " clicks";
         document.getElementById("player2Counter").textContent = playerTwo + ": " + (gameData.players[playerTwo].clicks || 0) + " clicks";
         if (gameData.status === "playing" && isDuelHost) {
            if (gameData.players[playerOne].clicks >= 100) {
              duelGameRef.update({ status: "ended", winner: playerOne, clientVersion: NEW_CLIENT_VERSION });
            } else if (gameData.players[playerTwo].clicks >= 100) {
              duelGameRef.update({ status: "ended", winner: playerTwo, clientVersion: NEW_CLIENT_VERSION });
            }
         }
      });
      if (isDuelHost) {
         duelCountdownInterval = setInterval(() => {
            duelGameRef.once("value", function(snap) {
               let gameData = snap.val();
               if (gameData.status === "countdown") {
                  if (gameData.countdown > 0) {
                     duelGameRef.update({ countdown: gameData.countdown - 1, clientVersion: NEW_CLIENT_VERSION });
                  } else {
                     duelGameRef.update({ status: "playing", clientVersion: NEW_CLIENT_VERSION });
                     clearInterval(duelCountdownInterval);
                  }
               }
            });
         }, 1000);
      }
    }

    function recordDuelSpeedClick() {
      duelGameRef.once("value", function(snap) {
         let gameData = snap.val();
         if (gameData.status !== "playing") return;
         let playerRef = duelGameRef.child("players/" + currentUser + "/clicks");
         playerRef.transaction(function(currentClicks) { return (currentClicks || 0) + 1; });
      });
    }

    function startRPSContest(targetUser) {
      if (!currentUser) { alert("Login required to challenge."); return; }
      if (targetUser.toLowerCase() === currentUser.toLowerCase()) { alert("Cannot challenge yourself!"); return; }
      let gameID = newDB.ref(NEW_KEYS.rpsGames).push().key;
      let contestData = {
         challenger: currentUser,
         challenged: targetUser,
         status: "pending",
         gameId: gameID,
         timestamp: firebase.database.ServerValue.TIMESTAMP,
         clientVersion: NEW_CLIENT_VERSION
      };
      newDB.ref(NEW_KEYS.rpsChallenges + "/" + gameID).set(contestData);
      alert("Rock–Paper–Scissors challenge sent to " + targetUser + "!");
    }

    function monitorRPSContests() {
      newDB.ref(NEW_KEYS.rpsChallenges).on("child_added", function(snap) {
         let contest = snap.val();
         if (contest.challenged.toLowerCase() === currentUser.toLowerCase() && contest.status === "pending") {
            if (!pendingRPSContest) {
              pendingRPSContest = contest;
              alert(contest.challenger + " has challenged you to Rock–Paper–Scissors! Type /accept to accept or /decline to decline.");
            }
         }
      });
      newDB.ref(NEW_KEYS.rpsChallenges).on("child_changed", function(snap) {
         let contest = snap.val();
         if (contest.challenged.toLowerCase() === currentUser.toLowerCase() && contest.status === "pending") {
            if (!pendingRPSContest) {
              pendingRPSContest = contest;
              alert(contest.challenger + " has challenged you to Rock–Paper–Scissors! Type /accept to accept or /decline to decline.");
            }
         }
         if (contest.challenger.toLowerCase() === currentUser.toLowerCase() && contest.status === "accepted") {
            acceptedRPSContest = contest;
            beginRPSMatch(contest.gameId, contest.challenger, contest.challenged);
         }
      });
    }

    function approveRPSContest() {
      if (!pendingRPSContest) { alert("No pending Rock–Paper–Scissors challenge."); return; }
      let gameID = pendingRPSContest.gameId;
      newDB.ref(NEW_KEYS.rpsChallenges + "/" + gameID).update({ status: "accepted", clientVersion: NEW_CLIENT_VERSION });
      beginRPSMatch(gameID, pendingRPSContest.challenger, pendingRPSContest.challenged);
      pendingRPSContest = null;
    }

    function rejectRPSContest() {
      if (!pendingRPSContest) { alert("No pending Rock–Paper–Scissors challenge."); return; }
      let gameID = pendingRPSContest.gameId;
      newDB.ref(NEW_KEYS.rpsChallenges + "/" + gameID).remove();
      pendingRPSContest = null;
      alert("Rock–Paper–Scissors challenge declined.");
    }

    function beginRPSMatch(gameID, playerOne, playerTwo) {
      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("rpsGameDiv").style.display = "block";
      rpsPlayerOne = playerOne;
      rpsPlayerTwo = playerTwo;
      rpsGameID = gameID;
      rpsGameRef = newDB.ref(NEW_KEYS.rpsGames + "/" + gameID);
      rpsGameRef.once("value", function(snap) {
         if (!snap.exists()) {
            rpsGameRef.set({
               players: {
                   [playerOne]: { choice: "" },
                   [playerTwo]: { choice: "" }
               },
               status: "waiting",
               clientVersion: NEW_CLIENT_VERSION
            });
         }
         initializeRPSMatch(gameID, playerOne, playerTwo);
      });
      newDB.ref(NEW_KEYS.rpsChallenges + "/" + gameID).remove();
    }

    function initializeRPSMatch(gameID, playerOne, playerTwo) {
      isRPSHost = (currentUser.toLowerCase() === playerOne.toLowerCase());
      rpsGameRef.on("value", function(snap) {
         let gameData = snap.val();
         if (!gameData) return;
         let choice1 = gameData.players[playerOne].choice;
         let choice2 = gameData.players[playerTwo].choice;
         if (choice1 !== "" && choice2 !== "" && gameData.status === "waiting") {
            let emoji1 = getRPSEmoji(choice1);
            let emoji2 = getRPSEmoji(choice2);
            let resultStr = "";
            if (choice1 === choice2) { resultStr = "It's a tie! Both chose " + choice1 + " " + emoji1 + "."; }
            else if ((choice1 === "rock" && choice2 === "scissors") || (choice1 === "scissors" && choice2 === "paper") || (choice1 === "paper" && choice2 === "rock")) {
              resultStr = playerOne + " wins! " + choice1 + " " + emoji1 + " beats " + choice2 + " " + emoji2 + ".";
            } else {
              resultStr = playerTwo + " wins! " + choice2 + " " + emoji2 + " beats " + choice1 + " " + emoji1 + ".";
            }
            rpsGameRef.update({ status: "finished", result: resultStr, clientVersion: NEW_CLIENT_VERSION });
         }
         if (gameData.status === "finished") {
            document.getElementById("rpsStatus").textContent = "Game Over";
            document.getElementById("rpsResult").textContent = gameData.result;
            document.getElementById("rpsChoices").style.display = "none";
            if (!rpsGameEndTimer) {
              rpsGameEndTimer = setTimeout(function() {
                document.getElementById("rpsGameDiv").style.display = "none";
                document.getElementById("chatDiv").style.display = "block";
                document.getElementById("messageInput").focus();
                restartRPSMatch();
                rpsGameEndTimer = null;
              }, 3000);
            }
         }
      });
    }

    function selectRPSOption(choice) {
      rpsGameRef.once("value", function(snap) {
         let gameData = snap.val();
         if (gameData.status !== "waiting") return;
         if (gameData.players[currentUser].choice === "") {
            rpsGameRef.child("players/" + currentUser + "/choice").set(choice);
            document.getElementById("rpsStatus").textContent = "Waiting for opponent's choice...";
         }
      });
    }

    function restartRPSMatch() {
      if (!rpsGameRef) return;
      rpsGameRef.set({
         players: {
            [rpsPlayerOne]: { choice: "" },
            [rpsPlayerTwo]: { choice: "" }
         },
         status: "waiting",
         clientVersion: NEW_CLIENT_VERSION
      });
      document.getElementById("rpsStatus").textContent = "Make your choice:";
      document.getElementById("rpsResult").textContent = "";
      document.getElementById("rpsChoices").style.display = "block";
      document.getElementById("rpsPlayAgainButton").style.display = "none";
    }

    function openSettingsPage() {
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("settingsDiv").style.display = "block";
    }

    function returnToSettingsOrLogin() {
      document.getElementById("settingsDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
    }

    function switchDarkMode() {
      document.body.classList.toggle("dark-mode");
      const darkActive = document.body.classList.contains("dark-mode");
      localStorage.setItem("darkModeEnabled", darkActive);
    }

    function adjustGuiScaling() {
      const scale = document.getElementById("guiSizeRange").value;
      document.documentElement.style.fontSize = (16 * scale) + "px";
      localStorage.setItem("uiScale", scale);
      refreshGuiScaleDisplay();
    }

    function refreshGuiScaleDisplay() {
      const val = document.getElementById("guiSizeRange").value;
      document.getElementById("guiSizeValue").textContent = `Current Scale: ${val}x`;
    }

    function changeUIFont() {
      document.body.classList.remove(
        "font-arial", "font-georgia", "font-courier", "font-comic", "font-roboto",
        "font-times", "font-verdana", "font-trebuchet", "font-lucida", "font-garamond",
        "font-helvetica", "font-tahoma", "font-impact", "font-futura", "font-open-sans", "font-lato", "font-montserrat"
      );
      const selected = document.getElementById("fontSelect").value;
      document.body.classList.add(selected);
      localStorage.setItem("selectedFont", selected);
    }

    function switchDesktopNotifications() {
      const toggled = document.getElementById("notificationsToggle").checked;
      localStorage.setItem("notificationsEnabled", toggled);
      if (toggled) { askNotificationAccess(); }
    }

    function askNotificationAccess() {
      if (!("Notification" in window)) { alert("This browser does not support notifications."); return; }
      if (Notification.permission !== "granted") {
        Notification.requestPermission().then((perm) => {
          if (perm !== "granted") { alert("Notifications blocked. Adjust settings."); document.getElementById("notificationsToggle").checked = false; localStorage.setItem("notificationsEnabled", false); }
        });
      }
    }

    function displayDMAlert(user, text) {
      const notifOn = localStorage.getItem("notificationsEnabled") === "true";
      if (!("Notification" in window) || !notifOn) return;
      if (document.hidden && Notification.permission === "granted") {
        new Notification("New DM from " + user, { body: text, icon: "https://via.placeholder.com/50" });
      }
    }

    // Improved presence initialization using Firebase's .info/connected.
    function initializeUserPresence() {
      const connectedRef = firebase.database().ref(".info/connected");
      connectedRef.on("value", function(snapshot) {
        if (snapshot.val() === true) {
          if (userPresenceRef) { 
            userPresenceRef.remove();
            userPresenceRef = null;
          }
          const presenceName = currentUser || ("Guest_" + Math.floor(Math.random() * 10000));
          userPresenceRef = newDB.ref(NEW_KEYS.presence).push();
          userPresenceRef.set({
            username: presenceName,
            timestamp: firebase.database.ServerValue.TIMESTAMP,
            clientVersion: NEW_CLIENT_VERSION
          });
          userPresenceRef.onDisconnect().remove();
        }
      });
    }

    // REWORKED MEMBERS LIST: Sorts alphabetically and uses custom list items.
    function refreshMemberList(members) {
      let sortedMembers = members.filter(m => m && m.trim() !== "").map(m => {
        if (m.toLowerCase().includes("anoynumus")) {
          return "Anonymous Player";
        }
        return m;
      });
      sortedMembers = [...new Set(sortedMembers)];
      sortedMembers.sort((a, b) => a.localeCompare(b));
      
      const memberListUl = document.getElementById("memberList");
      memberListUl.innerHTML = "";
      sortedMembers.forEach(member => {
        const li = document.createElement("li");
        li.className = "member-item";
        const avatar = document.createElement("div");
        avatar.className = "member-avatar";
        avatar.textContent = member.charAt(0).toUpperCase();
        const nameSpan = document.createElement("span");
        nameSpan.className = "member-name";
        nameSpan.textContent = member;
        li.appendChild(avatar);
        li.appendChild(nameSpan);
        memberListUl.appendChild(li);
      });
      const memberCountHeader = document.getElementById("memberListHeader");
      if (memberCountHeader) { 
        memberCountHeader.textContent = "Members Online";
      }
    }

    // Enables filtering of members based on input.
    function filterMemberList() {
      const filterValue = document.getElementById("memberListFilter").value.toLowerCase();
      const items = document.querySelectorAll("#memberList li.member-item");
      items.forEach(item => {
        const name = item.querySelector(".member-name").textContent.toLowerCase();
        if (name.includes(filterValue)) {
          item.style.display = "";
        } else {
          item.style.display = "none";
        }
      });
    }

    // Updated clearMemberList: Now clears the members from the server.
    function clearMemberList() {
      newDB.ref(NEW_KEYS.presence).remove()
        .then(() => {
          alert("Members list cleared from the server.");
        })
        .catch((error) => {
          alert("Error clearing members list: " + error);
        });
    }

    function switchBackgroundMusic() {
      const bgAudio = document.getElementById("bgMusic");
      if (bgAudio.paused) { bgAudio.play(); } else { bgAudio.pause(); }
    }

    function modifyMusicVolume() {
      const vol = document.getElementById("musicVolume").value;
      const bgAudio = document.getElementById("bgMusic");
      bgAudio.volume = vol;
      localStorage.setItem("musicVolume", vol);
    }

    function removeBackgroundMusic() {
      const bgAudio = document.getElementById("bgMusic");
      bgAudio.pause();
      bgAudio.src = "";
      localStorage.removeItem("bgMusic");
      alert("Background music removed!");
    }

    function switchSoundAlerts() {
      const enabled = document.getElementById("soundToggle").checked;
      localStorage.setItem("soundNotificationsEnabled", enabled);
    }

    function modifySoundVolume() {
      const vol = document.getElementById("soundVolume").value;
      const chatAud = document.getElementById("chatSound");
      chatAud.volume = vol;
      localStorage.setItem("soundVolume", vol);
    }

    function triggerSoundAlert() {
      const soundEnabled = localStorage.getItem("soundNotificationsEnabled") === "true";
      if (soundEnabled) { const chatAud = document.getElementById("chatSound"); chatAud.currentTime = 0; chatAud.play(); }
    }

    function switchTimestampDisplay() {
      const show = document.getElementById("timestampToggle").checked;
      localStorage.setItem("showTimestamps", show);
      alert("Message timestamp display " + (show ? "enabled" : "disabled") + ". (Hover over messages to see the sent time.)");
    }

    function hideChangeLog() { document.getElementById("changelogOverlay").style.display = "none"; }
    function displayHelpWindow() { document.getElementById("helpModal").style.display = "flex"; updateHelpWindowVisibility(); }
    function hideHelpWindow() { document.getElementById("helpModal").style.display = "none"; }
    function updateHelpWindowVisibility() {
      var opHelpElem = document.getElementById("opHelp");
      if (isUserOP()) { opHelpElem.style.display = "block"; }
      else { opHelpElem.style.display = "none"; }
    }

    window.onload = function() {
      document.getElementById("changelogOverlay").style.display = "flex";
      // Load dark mode setting
      const darkEnabled = localStorage.getItem("darkModeEnabled") === "true";
      if (darkEnabled) document.body.classList.add("dark-mode");
      document.getElementById("themeToggle").checked = darkEnabled;
      // Load UI scale
      const savedScale = localStorage.getItem("uiScale");
      if (savedScale) { document.documentElement.style.fontSize = (16 * savedScale) + "px"; document.getElementById("guiSizeRange").value = savedScale; }
      refreshGuiScaleDisplay();
      // Load font setting
      const savedFont = localStorage.getItem("selectedFont") || "font-arial";
      document.body.classList.add(savedFont);
      document.getElementById("fontSelect").value = savedFont;
      // Load account info
      currentUser = localStorage.getItem("acc_username");
      currentUserPassHash = localStorage.getItem("acc_passHash");
      refreshAccountInterface();
      // Fetch the op list from Firebase (assumed stored at "opList")
      fetchOpList();
      // Check for unauthorized op usage in older versions
      if (currentUser && !isUserOP()) {
        newDB.ref(NEW_KEYS.mutedUsers).orderByChild("op").equalTo(currentUser).once("value", (snap) => {
          if (snap.exists()) {
            alert("Unauthorized op command detected from a previous version. Your account will be terminated.");
            securelyTerminateAccount(currentUser);
          }
        });
      }
      activatePublicChatListeners();
      newDB.ref(NEW_KEYS.typing).on("value", (snap) => {
        const typObj = snap.val() || {};
        presentTypingStatus(typObj);
      });
      newDB.ref(NEW_KEYS.mutedUsers).on("value", (snap) => { mutedList = snap.val() || {}; });
      newDB.ref(NEW_KEYS.accountColors).on("value", (snap) => { userColors = snap.val() || {}; });
      newDB.ref(NEW_KEYS.broadcasts).on("child_added", (snap) => {
        const bData = snap.val();
        renderChatMessage(bData.user, bData.text, true, true, snap.key, bData.timestamp);
      });
      newDB.ref(NEW_KEYS.broadcasts).on("child_removed", (snap) => {
        const remKey = snap.key;
        const li = document.querySelector(`li[data-key="${remKey}"]`);
        if (li) li.remove();
      });
      newDB.ref(NEW_KEYS.presence).on("value", (snap) => {
        const presData = snap.val() || {};
        let membersArr = [];
        for (let key in presData) {
          if (presData[key].username) { membersArr.push(presData[key].username); }
        }
        refreshMemberList(membersArr);
      });
      initializeTextAreaShortcuts("messageInput", dispatchMessage);
      initializeTextAreaShortcuts("dmMessageInput", transmitDMChannel1);
      initializeTextAreaShortcuts("dm2MessageInput", transmitDMChannel2);
      initializeTextAreaShortcuts("dm3MessageInput", transmitDMChannel3);
      const notifEnabled = localStorage.getItem("notificationsEnabled") === "true";
      document.getElementById("notificationsToggle").checked = notifEnabled;
      const soundEnabled = localStorage.getItem("soundNotificationsEnabled") === "true";
      document.getElementById("soundToggle").checked = soundEnabled;
      const storedSoundVol = localStorage.getItem("soundVolume");
      if (storedSoundVol) { document.getElementById("soundVolume").value = storedSoundVol; document.getElementById("chatSound").volume = parseFloat(storedSoundVol); }
      const showTime = localStorage.getItem("showTimestamps") === "true";
      document.getElementById("timestampToggle").checked = showTime;
      window.onbeforeunload = () => { clearUserTypingStatus(); };
      const storedMusic = localStorage.getItem("bgMusic");
      if (storedMusic) {
        document.getElementById("bgMusic").src = storedMusic;
        document.getElementById("bgMusic").volume = localStorage.getItem("musicVolume") || 1;
        document.getElementById("bgMusic").play();
      }
      monitorDuelSpeedContests();
      monitorRPSContests();
      window.addEventListener("keydown", function(e) {
        if (e.key === "Escape") {
          if (document.getElementById("helpModal").style.display !== "none") { hideHelpWindow(); }
        }
      });
      updateHelpWindowVisibility();
      refreshOpSectionVisibility();
    };
  </script>
</body>
</html>
