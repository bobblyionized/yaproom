<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>yaproom (official)</title>
  <style>
    /* GENERAL RESET & CONTAINER */
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background: #f8f8f8; color: #333; padding: 10px;
      transition: background 0.3s, color 0.3s;
    }
    .container { max-width: 480px; margin: 0 auto; padding: 10px; }
    /* CONTAINERS (Login, Chat, Settings, Duel Speed Game, RPS Game) */
    #loginDiv, #chatDiv, #settingsDiv, #duelSpeedGameDiv, #rpsGameDiv {
      background: #ffffff; border-radius: 8px; padding: 16px; margin-top: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    /* Duel Speed Game UI */
    #duelSpeedGameDiv { text-align: center; }
    #duelSpeedCounters p { font-size: 18px; margin: 8px 0; }
    #duelSpeedClickButton {
      padding: 12px; font-size: 16px; border: none; border-radius: 6px;
      background: #7289da; color: #fff; cursor: pointer; transition: background 0.2s;
    }
    #duelSpeedClickButton:disabled {
      background: #ccc; cursor: not-allowed;
    }
    /* RPS Game UI */
    #rpsGameDiv { text-align: center; }
    #rpsChoices button {
      margin: 5px; padding: 10px 20px; font-size: 16px;
      border: none; border-radius: 6px; background: #7289da; color: #fff;
      cursor: pointer; transition: background 0.2s;
    }
    #rpsChoices button:hover { background: #677bc4; }
    #rpsResult { margin-top: 10px; font-size: 16px; font-weight: bold; }
    /* DARK MODE */
    body.dark-mode {
      background: #2f3136; color: #dcdcdc;
    }
    body.dark-mode #loginDiv,
    body.dark-mode #chatDiv,
    body.dark-mode #settingsDiv,
    body.dark-mode #duelSpeedGameDiv,
    body.dark-mode #rpsGameDiv {
      background: #36393f; color: #dcdcdc;
    }
    body.dark-mode textarea {
      background: #40444b; color: #dcdcdc; border: 1px solid #4f545c;
    }
    body.dark-mode button {
      background: #4f545c; color: #dcdcdc; border: 1px solid #4f545c;
    }
    body.dark-mode select {
      background: #40444b; color: #dcdcdc; border: 1px solid #4f545c;
    }
    /* FORM ELEMENTS */
    input[type="text"], textarea, select {
      width: 100%; padding: 8px; margin-bottom: 8px; border: 1px solid #ccc;
      border-radius: 6px; font-size: 14px;
    }
    button {
      width: 100%; padding: 8px; border: none; border-radius: 6px;
      background: #7289da; color: #fff; font-size: 14px; cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: #677bc4; }
    /* HEADERS & TEXT */
    h2, h3 { margin-bottom: 12px; font-weight: 600; }
    p { margin-bottom: 8px; font-size: 14px; }
    .tutorial-box {
      background: #fafafa; padding: 6px; border-radius: 4px; font-size: 13px;
      margin-bottom: 8px;
    }
    body.dark-mode .tutorial-box { background: #40444b; color: #dcdcdc; }
    /* CHAT MESSAGES */
    #messages {
      list-style: none; padding: 0; max-height: 300px; overflow-y: auto;
      margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px;
      background: #ffffff;
    }
    body.dark-mode #messages { background: #40444b; border-color: #4f545c; }
    #messages li {
      padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 14px;
    }
    #messages li:last-child { border-bottom: none; }
    .account-user { color: #7289da; font-weight: bold; }
    .anonymous-user { color: #333; }
    .broadcast-msg {
      background: #ffeb3b; color: #333; font-weight: bold;
      padding: 4px; border-radius: 4px;
    }
    /* TEXTAREA AUTO-RESIZE */
    textarea { resize: none; min-height: 40px; max-height: 120px; overflow-y: auto; }
    /* DM SECTION */
    #dmSection { margin-top: 10px; border-top: 1px solid #ccc; padding-top: 8px; }
    #dmMessages, #dm2Messages, #dm3Messages {
      list-style: none; padding: 0; max-height: 200px; overflow-y: auto;
      margin-bottom: 8px; border: 1px solid #ddd; border-radius: 4px;
      background: #ffffff;
    }
    body.dark-mode #dmMessages,
    body.dark-mode #dm2Messages,
    body.dark-mode #dm3Messages {
      background: #40444b; border-color: #4f545c;
    }
    #dmMessages li, #dm2Messages li, #dm3Messages li {
      padding: 6px 8px; border-bottom: 1px solid #eee; font-size: 14px;
    }
    /* MEMBER LIST */
    #memberListContainer {
      background: #ffffff; padding: 8px; margin-top: 10px;
      border: 1px solid #ddd; border-radius: 6px;
    }
    body.dark-mode #memberListContainer {
      background: #36393f; border-color: #4f545c;
    }
    #memberList li { padding: 4px 0; font-size: 14px; }
    /* Member count header */
    #memberCountHeader { margin-bottom: 8px; }
    /* MESSAGE ANIMATION */
    @keyframes message-enter {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }
    .message-enter { animation: message-enter 0.3s ease forwards; }
    /* EXTRA SETTINGS HEADINGS */
    #settingsDiv h3 { margin-top: 16px; margin-bottom: 8px; font-weight: 600; }
    /* Hide audio elements */
    audio { display: none; }
    /* Changelog & Help Modal Overlays */
    #changelogOverlay, #helpModal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background-color: rgba(0,0,0,0.7); display: none;
      justify-content: center; align-items: center; z-index: 9999;
      transition: opacity 0.3s ease;
    }
    #changelogModal, #helpModalContent {
      background: #fff; padding: 20px; border-radius: 10px;
      max-width: 400px; width: 90%; color: #000;
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }
    #changelogModal ul, #helpModalContent ul {
      margin: 10px 0; padding-left: 30px;
    }
    /* Custom Font Classes */
    .font-arial { font-family: Arial, sans-serif; }
    .font-georgia { font-family: Georgia, serif; }
    .font-courier { font-family: "Courier New", monospace; }
    .font-comic { font-family: "Comic Sans MS", cursive, sans-serif; }
    .font-roboto { font-family: Roboto, sans-serif; }
    .font-times { font-family: "Times New Roman", Times, serif; }
    .font-verdana { font-family: Verdana, sans-serif; }
    .font-trebuchet { font-family: "Trebuchet MS", sans-serif; }
    .font-lucida { font-family: "Lucida Sans Unicode", sans-serif; }
    .font-garamond { font-family: Garamond, serif; }
    .font-helvetica { font-family: Helvetica, sans-serif; }
    .font-tahoma { font-family: Tahoma, sans-serif; }
    .font-impact { font-family: Impact, sans-serif; }
    .font-futura { font-family: Futura, sans-serif; }
    .font-open-sans { font-family: "Open Sans", sans-serif; }
    .font-lato { font-family: Lato, sans-serif; }
    .font-montserrat { font-family: Montserrat, sans-serif; }
  </style>
</head>
<body>
  <div class="container">
    <!-- Changelog Overlay -->
    <div id="changelogOverlay">
      <div id="changelogModal">
        <h2>Alpha V2.0.0</h2>
        <ul>
          <li>Cleaned up the UI for a modern light mode experience.</li>
          <li>Improved compact layout inspired by Discord mobile.</li>
          <li>Added background music controls, sound notifications, and message timestamp toggles in settings.</li>
          <li>Minor bug fixes and performance improvements.</li>
          <li><strong>New:</strong> Duel Speed minigame via /duelspeed command (first to 100 clicks wins)!</li>
          <li><strong>New:</strong> Rock–Paper–Scissors minigame via /rps command!</li>
        </ul>
        <button onclick="closeChangelog()">Close</button>
      </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal">
      <div id="helpModalContent">
        <h2>Help &amp; Commands</h2>
        <ul>
          <li>/createroom [roomName] - Create a group chat room</li>
          <li>/join [roomName] - Join a group chat room</li>
          <li>/invite [accountName] - Invite someone to a group chat room</li>
          <li>/leave - Leave the current group chat room</li>
          <li>/duelspeed [account] - Challenge someone to a Duel Speed game</li>
          <li>/rps [account] - Challenge someone to a Rock–Paper–Scissors game</li>
          <li>/accept - Accept a pending challenge</li>
          <li>/decline - Decline a pending challenge</li>
          <!-- OP commands container -->
          <span id="opHelp" style="display:none;">
            <li>/mute [username] - (OP Only) Mute a user</li>
            <li>/unmute [username] - (OP Only) Unmute a user</li>
            <li>/terminate [accountName] - (OP Only) Terminate an account</li>
          </span>
        </ul>
        <button onclick="closeHelpModal()">Close</button>
      </div>
    </div>

    <!-- LOGIN SCREEN -->
    <div id="loginDiv">
      <h2>Enter Chat</h2>
      <p>Anonymous / Temporary Name:</p>
      <input type="text" id="anonymousInput" class="username-input" placeholder="Anonymous Name" />
      <button onclick="startChatting()" class="enter-chat-btn">Start Chatting</button>
      <hr />
      <h3>Account</h3>
      <div id="notLoggedInUI">
        <input type="text" id="accNameInput" placeholder="Desired username" />
        <input type="text" id="accPassInput" placeholder="Password" />
        <button onclick="createOrLoginAccount()">Create/Login Account</button>
      </div>
      <div id="loggedInUI" style="display:none;">
        <p>Logged in as: <span id="loggedInName"></span></p>
        <input type="text" id="renameInput" placeholder="New username" />
        <button onclick="renameAccount()">Rename Account</button>
        <br /><br />
        <input type="text" id="changePassInput" placeholder="New Password" />
        <button onclick="changePassword()">Change Password</button>
        <br /><br />
        <button onclick="logOutAccount()">Log Out</button>
      </div>
      <hr />
      <button onclick="showSettingsFromLogin()">Settings</button>
      <!-- OP-ONLY Section -->
      <div id="opSection" style="display:none; margin-top: 10px; border-top:1px solid #ccc; padding-top:10px;">
        <h3>OP Tools</h3>
        <button onclick="clearChatForEveryone()">Clear Chat (Server-Side)</button>
        <br /><br />
        <label for="opBroadcastInput">Broadcast Message:</label>
        <input type="text" id="opBroadcastInput" />
        <button onclick="sendBroadcast()">Send Broadcast</button>
        <br /><br />
        <label for="opColorPicker">Change Your Name Color:</label>
        <input type="color" id="opColorPicker" value="#7289da" />
        <button onclick="setOpColor()">Set Name Color</button>
        <br /><br />
        <button onclick="clearAllTyping()">Clear All 'Typing'</button>
      </div>
    </div>

    <!-- CHAT SCREEN -->
    <div id="chatDiv" style="display:none;">
      <h2>Yap Room</h2>
      <div class="tutorial-box">
        <strong>Group Chat Commands:</strong><br/>
        /createroom [roomName]<br/>
        /join [roomName]<br/>
        /invite [accountName]<br/>
        /leave<br/><br/>
        <strong>Duel Speed Command:</strong><br/>
        /duelspeed [account]<br/>
        (Then type /accept or /decline.)<br/><br/>
        <strong>Rock–Paper–Scissors Command:</strong><br/>
        /rps [account]<br/>
        (Then type /accept or /decline.)
      </div>
      <ul id="messages"></ul>
      <div id="typingStatus"></div>
      <div class="chat-controls">
        <textarea id="messageInput" placeholder="Type a message" oninput="handleTyping()"></textarea>
        <button onclick="sendMessage()">Send</button>
        <button onclick="clearChat()">Clear Chat</button>
      </div>
      <!-- DM Section -->
      <div id="dmSection">
        <h3>Direct Messages</h3>
        <div id="dmLoginWarning" style="color:red; display:none;">You must be logged in to use DMs.</div>
        <div id="dmUI" style="display:none;">
          <!-- DM #1 -->
          <p><strong>DM #1</strong> – Type a username to DM:</p>
          <input type="text" id="dmTargetInput" placeholder="Username to DM" />
          <button onclick="openDM()">Open DM</button>
          <div id="dmConversation" style="display:none; margin-top:10px;">
            <ul id="dmMessages"></ul>
            <div class="dm-controls">
              <textarea id="dmMessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
              <button onclick="sendDM()">Send DM</button>
            </div>
          </div>
          <hr/>
          <!-- DM #2 -->
          <p><strong>DM #2</strong> – Type a username to DM:</p>
          <input type="text" id="dm2TargetInput" placeholder="Username to DM" />
          <button onclick="openDM2()">Open DM #2</button>
          <div id="dm2Conversation" style="display:none; margin-top:10px;">
            <ul id="dm2Messages"></ul>
            <div class="dm-controls">
              <textarea id="dm2MessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
              <button onclick="sendDM2()">Send DM #2</button>
            </div>
          </div>
          <hr/>
          <!-- DM #3 -->
          <p><strong>DM #3</strong> – Type a username to DM:</p>
          <input type="text" id="dm3TargetInput" placeholder="Username to DM" />
          <button onclick="openDM3()">Open DM #3</button>
          <div id="dm3Conversation" style="display:none; margin-top:10px;">
            <ul id="dm3Messages"></ul>
            <div class="dm-controls">
              <textarea id="dm3MessageInput" placeholder="Type a direct message" oninput="handleTyping()"></textarea>
              <button onclick="sendDM3()">Send DM #3</button>
            </div>
          </div>
        </div>
      </div>
      <div id="memberListContainer">
        <h3 id="memberCountHeader">Members Online</h3>
        <ul id="memberList"></ul>
      </div>
      <div style="text-align:center; margin-top:10px;">
        <button onclick="returnToLogin()">Return to Main Screen</button>
        <button onclick="openHelpModal()">Help</button>
      </div>
    </div>

    <!-- SETTINGS SCREEN -->
    <div id="settingsDiv" style="display:none;">
      <h2>Settings</h2>
      <!-- Basic Settings -->
      <label>
        <input type="checkbox" id="themeToggle" onchange="toggleDarkMode()" />
        Dark Mode
      </label>
      <br/><br/>
      <label for="guiSizeRange">GUI Size</label>
      <input type="range" id="guiSizeRange" min="0.5" max="2.0" step="0.1" value="1.0" onchange="updateGuiSize()" />
      <p id="guiSizeValue"></p>
      <label for="fontSelect">Choose Font:</label>
      <select id="fontSelect" onchange="updateFont()">
        <option value="font-arial">Arial</option>
        <option value="font-georgia">Georgia</option>
        <option value="font-courier">Courier New</option>
        <option value="font-comic">Comic Sans MS</option>
        <option value="font-roboto">Roboto</option>
        <option value="font-times">Times New Roman</option>
        <option value="font-verdana">Verdana</option>
        <option value="font-trebuchet">Trebuchet MS</option>
        <option value="font-lucida">Lucida Sans Unicode</option>
        <option value="font-garamond">Garamond</option>
        <option value="font-helvetica">Helvetica</option>
        <option value="font-tahoma">Tahoma</option>
        <option value="font-impact">Impact</option>
        <option value="font-futura">Futura</option>
        <option value="font-open-sans">Open Sans</option>
        <option value="font-lato">Lato</option>
        <option value="font-montserrat">Montserrat</option>
      </select>
      <br/><br/>
      <label>
        <input type="checkbox" id="notificationsToggle" onchange="toggleNotifications()" />
        Enable Desktop Notifications
      </label>
      <br/><br/>
      <!-- Extra Settings Features -->
      <h3>Background Music</h3>
      <label for="musicFileInput">Upload Music:</label>
      <input type="file" id="musicFileInput" accept="audio/*" />
      <br/>
      <button onclick="toggleMusic()">Play/Pause Music</button>
      <label>Volume:</label>
      <input type="range" id="musicVolume" min="0" max="1" step="0.01" value="1" onchange="updateMusicVolume()" />
      <button onclick="clearMusic()">Remove Music</button>
      <br/><br/>
      <h3>Sound Notifications</h3>
      <label>
        <input type="checkbox" id="soundToggle" onchange="toggleSoundNotifications()" />
        Enable Chat Sound Notifications
      </label>
      <br/>
      <label for="soundVolume">Sound Volume:</label>
      <input type="range" id="soundVolume" min="0" max="1" step="0.01" value="1" onchange="updateSoundVolume()" />
      <br/><br/>
      <h3>Message Timestamps</h3>
      <label>
        <input type="checkbox" id="timestampToggle" onchange="toggleTimestamps()" />
        Show Message Timestamps (hover to view)
      </label>
      <br/><br/>
      <button onclick="goBack()">Back</button>
    </div>
    
    <!-- DUEL SPEED GAME UI -->
    <div id="duelSpeedGameDiv" style="display:none;">
      <h2>Duel Speed</h2>
      <div id="duelSpeedStatus">Get Ready...</div>
      <div id="duelSpeedCounters">
        <p id="player1Counter"></p>
        <p id="player2Counter"></p>
      </div>
      <button id="duelSpeedClickButton" onclick="registerDuelSpeedClick()">Click Me!</button>
    </div>

    <!-- ROCK-PAPER-SCISSORS GAME UI -->
    <div id="rpsGameDiv" style="display:none;">
      <h2>Rock–Paper–Scissors</h2>
      <div id="rpsStatus">Make your choice:</div>
      <div id="rpsChoices">
        <button onclick="makeRPSChoice('rock')">Rock ✊</button>
        <button onclick="makeRPSChoice('paper')">Paper ✋</button>
        <button onclick="makeRPSChoice('scissors')">Scissors ✌️</button>
      </div>
      <div id="rpsResult"></div>
      <!-- The "Play Again" button remains hidden because the game auto-returns to chat -->
      <button id="rpsPlayAgainButton" style="display:none;" onclick="resetRPSGame()">Play Again</button>
    </div>
  </div>

  <!-- Hidden Audio Elements -->
  <audio id="bgMusic" loop></audio>
  <audio id="chatSound" src="https://www.soundjay.com/button/beep-07.wav" preload="auto"></audio>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.11/firebase-database-compat.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/js-sha256/0.9.0/sha256.min.js"></script>

  <script>
    /* =====================================================
       Firebase Configuration & Initialization
       ===================================================== */
    const firebaseConfig = {
      apiKey: "AIzaSyBkm5Lf3PaghllqcatG_FymhTm_x7mGa28",
      authDomain: "yaproom-14cfe.firebaseapp.com",
      databaseURL: "https://yaproom-14cfe-default-rtdb.firebaseio.com",
      projectId: "yaproom-14cfe",
      storageBucket: "yaproom-14cfe.appspot.com",
      messagingSenderId: "5332542311",
      appId: "1:5332542311:web:f1a1ab2fb81bf62b0b45c2"
    };
    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    /* =====================================================
       Global Variables & OP List
       ===================================================== */
    const OP_LIST = ["god", "nubunknown", "pasta"];
    let lastMessageTime = 2000;
    const RATE_LIMIT_MS = 2000;
    const badWords = ["shit","fuck","bitch","nigga","fucking","shitting","negro","bullshit","pussy"];
    let currentUsername = null;
    let currentPassHash = null;
    let accountDeletedRef = null;
    let renamingInProgress = false;
    let currentDMPath = null, dmListener = null;
    let currentDM2Path = null, dm2Listener = null;
    let currentDM3Path = null, dm3Listener = null;
    let inGroupChat = false, currentGroupRoomName = null, groupListener = null;
    let typingTimeout = null;
    let mutedUsers = {};
    let accountColors = {};
    let publicMessages = [];
    let publicListenerAdd = null, publicListenerRemove = null;
    let myPresenceRef = null;

    // ---- Global variables for Duel Speed minigame ----
    let pendingDuelSpeedChallenge = null;
    let acceptedDuelSpeedChallenge = null;
    let duelSpeedGameId = null;
    let isDuelSpeedHost = false;
    let duelSpeedGameRef = null;
    let duelSpeedCountdownInterval = null;

    // ---- Global variables for Rock-Paper–Scissors (RPS) minigame ----
    let pendingRPSChallenge = null;
    let acceptedRPSChallenge = null;
    let rpsGameId = null;
    let isRPSHost = false;
    let rpsGameRef = null;
    let rpsPlayer1 = "";
    let rpsPlayer2 = "";
    let rpsGameEndTimeout = null;

    // Utility function to get emoji for a choice
    function getEmoji(choice) {
      if (choice === "rock") return "✊";
      if (choice === "paper") return "✋";
      if (choice === "scissors") return "✌️";
      return "";
    }

    /* =====================================================
       Helper: Check if current user is an approved OP.
       ===================================================== */
    function isCurrentUserOP() {
      return currentUsername && OP_LIST.includes(currentUsername.toLowerCase());
    }

    /* =====================================================
       Helper: Update display of OP Tools.
       ===================================================== */
    function checkIfOP() {
      const opSection = document.getElementById("opSection");
      if (opSection) { opSection.style.display = isCurrentUserOP() ? "block" : "none"; }
    }

    /* =====================================================
       OP Command Functions – If a non-approved user uses any OP command, they are terminated.
       ===================================================== */
    function handleOpCommand(cmd, target) {
      if (!target) { alert("Usage: " + cmd + " [username]"); return; }
      if (!isCurrentUserOP()) {
        alert("Unauthorized op command detected. Your account will be terminated.");
        terminateAccount(currentUsername);
        return;
      }
      if (cmd === "/mute") {
        db.ref("mutedUsers/" + target).set({ value: true, op: currentUsername });
        alert(`User "${target}" has been muted.`);
      } else if (cmd === "/unmute") {
        db.ref("mutedUsers/" + target).remove();
        alert(`User "${target}" has been unmuted.`);
      }
    }

    async function terminateAccount(target) {
      if (!isCurrentUserOP() && target === currentUsername) {
        alert("Unauthorized op command detected. Your account will now be terminated.");
      }
      try {
        await db.ref("accounts/" + target).remove();
        await db.ref("accountColors/" + target).remove();
        await db.ref("typing/" + target).remove();
        await db.ref("mutedUsers/" + target).remove();
        const msgsSnap = await db.ref("messages").once("value");
        msgsSnap.forEach((childSnap) => {
          const val = childSnap.val();
          if (val.user && val.user === target) { childSnap.ref.remove(); }
        });
        alert(`Account "${target}" has been TERMINATED.`);
        if (target === currentUsername) { logOutAccount(); }
      } catch (err) {
        alert("Error terminating account: " + err);
      }
    }

    async function clearChatForEveryone() {
      if (!isCurrentUserOP()) {
        alert("Unauthorized op command detected. Your account will be terminated.");
        terminateAccount(currentUsername);
        return;
      }
      const confirmClear = confirm("Are you sure you want to clear the public chat AND all broadcasts for EVERYONE?");
      if (!confirmClear) return;
      await db.ref("messages").remove();
      await db.ref("broadcasts").remove();
      document.getElementById("messages").innerHTML = "";
      publicMessages = [];
      alert("All messages and broadcasts cleared for everyone.");
    }

    function sendBroadcast() {
      if (!isCurrentUserOP()) {
        alert("Unauthorized op command detected. Your account will be terminated.");
        terminateAccount(currentUsername);
        return;
      }
      const broadcastInput = document.getElementById("opBroadcastInput");
      const text = broadcastInput.value.trim();
      if (!text) return;
      db.ref("broadcasts").push({
        user: currentUsername,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      broadcastInput.value = "";
      alert("Broadcast sent!");
    }

    function setOpColor() {
      if (!isCurrentUserOP()) {
        alert("Unauthorized op command detected. Your account will be terminated.");
        terminateAccount(currentUsername);
        return;
      }
      const colorPicker = document.getElementById("opColorPicker");
      const chosenColor = colorPicker.value;
      db.ref("accountColors/" + currentUsername).set(chosenColor);
      alert("Your chat color has been updated to: " + chosenColor);
    }

    function clearAllTyping() {
      if (!isCurrentUserOP()) {
        alert("Unauthorized op command detected. Your account will be terminated.");
        terminateAccount(currentUsername);
        return;
      }
      db.ref("typing").remove();
      alert("All 'typing' statuses have been cleared for everyone.");
    }

    /* =====================================================
       On Page Load & Other Functions
       ===================================================== */
    window.onload = function() {
      document.getElementById("changelogOverlay").style.display = "flex";
      // Dark Mode
      const darkModeEnabled = localStorage.getItem("darkModeEnabled") === "true";
      if (darkModeEnabled) document.body.classList.add("dark-mode");
      document.getElementById("themeToggle").checked = darkModeEnabled;
      // GUI Size
      const savedScale = localStorage.getItem("uiScale");
      if (savedScale) {
        document.documentElement.style.fontSize = (16 * savedScale) + "px";
        document.getElementById("guiSizeRange").value = savedScale;
      }
      updateGuiSizeDisplay();
      // Font
      const savedFont = localStorage.getItem("selectedFont") || "font-arial";
      document.body.classList.add(savedFont);
      document.getElementById("fontSelect").value = savedFont;
      // Account
      currentUsername = localStorage.getItem("acc_username");
      currentPassHash = localStorage.getItem("acc_passHash");
      updateAccountUI();
      // Check for unauthorized op usage from previous versions.
      if (currentUsername && !isCurrentUserOP()) {
        db.ref("mutedUsers").orderByChild("op").equalTo(currentUsername).once("value", (snapshot) => {
          if (snapshot.exists()) {
            alert("Unauthorized op command detected from a previous version. Your account will be terminated.");
            terminateAccount(currentUsername);
          }
        });
      }
      // Public Chat Listener
      startPublicChatListeners();
      // Typing Updates
      db.ref("typing").on("value", (snap) => {
        const typingObj = snap.val() || {};
        showTypingStatus(typingObj);
      });
      // Muted Users
      db.ref("mutedUsers").on("value", (snap) => { mutedUsers = snap.val() || {}; });
      // Account Colors
      db.ref("accountColors").on("value", (snap) => { accountColors = snap.val() || {}; });
      // Broadcasts
      db.ref("broadcasts").on("child_added", (snap) => {
        const bData = snap.val();
        displayMessage(bData.user, bData.text, true, true, snap.key);
      });
      db.ref("broadcasts").on("child_removed", (snap) => {
        const removedKey = snap.key;
        const li = document.querySelector(`li[data-key="${removedKey}"]`);
        if (li) li.remove();
      });
      // Presence
      db.ref("presence").on("value", (snapshot) => {
        const presenceData = snapshot.val() || {};
        let members = [];
        for (let key in presenceData) {
          if (presenceData[key].username) { members.push(presenceData[key].username); }
        }
        updateMemberList(members);
      });
      // Textarea Shortcuts
      setupTextareaShortcuts("messageInput", sendMessage);
      setupTextareaShortcuts("dmMessageInput", sendDM);
      setupTextareaShortcuts("dm2MessageInput", sendDM2);
      setupTextareaShortcuts("dm3MessageInput", sendDM3);
      // Notifications Setting
      const notificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      document.getElementById("notificationsToggle").checked = notificationsEnabled;
      // Sound Notifications Setting
      const soundEnabled = localStorage.getItem("soundNotificationsEnabled") === "true";
      document.getElementById("soundToggle").checked = soundEnabled;
      const savedSoundVolume = localStorage.getItem("soundVolume");
      if (savedSoundVolume) {
        document.getElementById("soundVolume").value = savedSoundVolume;
        document.getElementById("chatSound").volume = parseFloat(savedSoundVolume);
      }
      // Message Timestamps Toggle
      const showTimestamps = localStorage.getItem("showTimestamps") === "true";
      document.getElementById("timestampToggle").checked = showTimestamps;
      // Remove typing on unload
      window.onbeforeunload = () => removeUserTyping();
      // Background Music
      const storedMusic = localStorage.getItem("bgMusic");
      if (storedMusic) {
        document.getElementById("bgMusic").src = storedMusic;
        document.getElementById("bgMusic").volume = localStorage.getItem("musicVolume") || 1;
        document.getElementById("bgMusic").play();
      }
      // Listen for Duel Speed and RPS challenges
      listenForDuelSpeedChallenges();
      listenForRPSChallenges();
      // Keyboard shortcut: Escape to close help modal if open
      window.addEventListener("keydown", function(e) {
        if (e.key === "Escape") {
          if (document.getElementById("helpModal").style.display !== "none") {
            closeHelpModal();
          }
        }
      });
      updateHelpModalVisibility();
      checkIfOP();
    };

    function closeChangelog() {
      document.getElementById("changelogOverlay").style.display = "none";
    }
    
    function openHelpModal() {
      document.getElementById("helpModal").style.display = "flex";
      updateHelpModalVisibility();
    }
    
    function closeHelpModal() {
      document.getElementById("helpModal").style.display = "none";
    }
    
    // Only show OP commands in the help modal if current user is an OP.
    function updateHelpModalVisibility() {
      var opHelpContainer = document.getElementById("opHelp");
      if (isCurrentUserOP()) { opHelpContainer.style.display = "block"; }
      else { opHelpContainer.style.display = "none"; }
    }

    function setupTextareaShortcuts(textareaId, sendCallback) {
      const textarea = document.getElementById(textareaId);
      textarea.addEventListener("keydown", function(e) {
        if (e.key === "Enter" && !e.shiftKey) {
          e.preventDefault();
          sendCallback();
        }
      });
      textarea.addEventListener("input", autoResize);
    }

    function autoResize(event) {
      const textarea = event.target;
      textarea.style.height = "auto";
      textarea.style.height = (textarea.scrollHeight) + "px";
    }

    /* =====================================================
       Public Chat Listener
       ===================================================== */
    function startPublicChatListeners() {
      db.ref("messages").off("child_added", publicListenerAdd);
      db.ref("messages").off("child_removed", publicListenerRemove);
      publicMessages = [];
      document.getElementById("messages").innerHTML = "";
      publicListenerAdd = db.ref("messages").on("child_added", (snapshot) => {
        const msg = snapshot.val();
        const key = snapshot.key;
        if (msg.user && mutedUsers[msg.user]) return;
        publicMessages.push({ key, ...msg });
        if (!inGroupChat) {
          displayMessage(msg.user, msg.text, msg.isAccount, false, key, msg.timestamp);
        }
        if (msg.user && msg.text) { checkForMentionsAndNotify(msg.user, msg.text); }
      });
      publicListenerRemove = db.ref("messages").on("child_removed", (snap) => {
        const removedKey = snap.key;
        publicMessages = publicMessages.filter(m => m.key !== removedKey);
        if (!inGroupChat) {
          const li = document.querySelector(`li[data-key="${removedKey}"]`);
          if (li) li.remove();
        }
      });
    }

    function checkForMentionsAndNotify(sender, text) {
      if (!currentUsername || !text) return;
      const textLower = text.toLowerCase();
      const mentionString = "@" + currentUsername.toLowerCase();
      if (textLower.includes(mentionString) && sender !== currentUsername) {
        showMentionNotification(sender, text);
      }
    }

    function showMentionNotification(sender, text) {
      const isNotificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      if (!("Notification" in window) || !isNotificationsEnabled) return;
      if (document.hidden && Notification.permission === "granted") {
        new Notification("You were mentioned by " + sender, {
          body: text,
          icon: "https://via.placeholder.com/50"
        });
      }
    }

    /* =====================================================
       Account Creation / Login
       ===================================================== */
    async function createOrLoginAccount() {
      let desiredName = document.getElementById("accNameInput").value.trim();
      const desiredPass = document.getElementById("accPassInput").value.trim();
      if (!desiredName || !desiredPass) {
        alert("Please provide both a username and a password.");
        return;
      }
      if (/\s/.test(desiredName)) {
        alert("Usernames cannot contain spaces.");
        return;
      }
      // If the desired name is in the reserved OP list, disallow account creation if it doesn't exist already.
      if (OP_LIST.includes(desiredName.toLowerCase())) {
        desiredName = desiredName.toLowerCase();
        const snapCheck = await db.ref("accounts/" + desiredName).once("value");
        if (!snapCheck.exists()) {
          alert("You are not authorized to create an op account.");
          return;
        }
        // If the account exists, also check that it is flagged as an authorized op.
        if (!snapCheck.val().isOp) {
          alert("This op account is not authorized.");
          return;
        }
      }
      const passHash = sha256(desiredPass);
      try {
        const snap = await db.ref("accounts/" + desiredName).once("value");
        if (!snap.exists()) {
          // Only authorized op accounts should exist in the reserved names.
          await db.ref("accounts/" + desiredName).set({
            passwordHash: passHash,
            createdAt: Date.now(),
            // Mark as authorized op if the username is in the op list.
            isOp: OP_LIST.includes(desiredName)
          });
          alert("Account created! Logged in as: " + desiredName);
        } else {
          const data = snap.val();
          if (data.passwordHash !== passHash) {
            alert("Incorrect password or name is taken by someone else.");
            return;
          }
          // If this is an op account, check for authorization.
          if (OP_LIST.includes(desiredName) && !data.isOp) {
            alert("This op account is not authorized.");
            return;
          }
          alert("Logged in successfully as: " + desiredName);
        }
        currentUsername = desiredName;
        currentPassHash = passHash;
        localStorage.setItem("acc_username", currentUsername);
        localStorage.setItem("acc_passHash", currentPassHash);
        updateAccountUI();
      } catch (err) {
        alert("Error creating/logging in: " + err);
      }
    }

    function updateAccountUI() {
      const notLoggedInUI = document.getElementById("notLoggedInUI");
      const loggedInUI = document.getElementById("loggedInUI");
      const loggedInName = document.getElementById("loggedInName");
      const anonInput = document.getElementById("anonymousInput");
      if (currentUsername && currentPassHash) {
        notLoggedInUI.style.display = "none";
        loggedInUI.style.display = "block";
        loggedInName.textContent = currentUsername;
        anonInput.value = currentUsername;
        anonInput.disabled = true;
        listenForAccountDeletion();
        listenForDuelSpeedChallenges();
        listenForRPSChallenges();
      } else {
        notLoggedInUI.style.display = "block";
        loggedInUI.style.display = "none";
        anonInput.value = "";
        anonInput.disabled = false;
        if (accountDeletedRef) { accountDeletedRef.off("value"); accountDeletedRef = null; }
      }
      updateDMUI();
      checkIfOP();
    }

    function listenForAccountDeletion() {
      if (accountDeletedRef) { accountDeletedRef.off("value"); accountDeletedRef = null; }
      if (!currentUsername) return;
      accountDeletedRef = db.ref("accounts/" + currentUsername);
      accountDeletedRef.on("value", (snap) => {
        if (!snap.exists() && !renamingInProgress) {
          alert("Your account has been terminated!");
          logOutAccount();
        }
      });
    }

    async function logOutAccount() {
      removeUserTyping();
      if (accountDeletedRef) { accountDeletedRef.off("value"); accountDeletedRef = null; }
      if (myPresenceRef) { myPresenceRef.remove(); myPresenceRef = null; }
      localStorage.removeItem("acc_username");
      localStorage.removeItem("acc_passHash");
      currentUsername = null;
      currentPassHash = null;
      alert("Logged out.");
      updateAccountUI();
    }

    function removeUserTyping() {
      if (currentUsername) { db.ref("typing/" + currentUsername).remove(); }
    }

    /* =====================================================
       Rename Account (12-hour lock)
       ===================================================== */
    async function renameAccount() {
      if (!currentUsername || !currentPassHash) {
        alert("You are not logged in, can't rename.");
        return;
      }
      const newNameInput = document.getElementById("renameInput").value.trim();
      if (!newNameInput) {
        alert("Enter a new username.");
        return;
      }
      if (/\s/.test(newNameInput)) {
        alert("Usernames cannot contain spaces!");
        return;
      }
      const snap = await db.ref("accounts/" + currentUsername).once("value");
      if (!snap.exists()) {
        alert("Your account no longer exists or was deleted.");
        return;
      }
      const currentAccData = snap.val();
      const lastRenamed = currentAccData.lastRenamed || 0;
      const now = Date.now();
      const TWELVE_HOURS = 12 * 60 * 60 * 1000;
      if (now - lastRenamed < TWELVE_HOURS) {
        const timeLeftMs = TWELVE_HOURS - (now - lastRenamed);
        const timeLeftHr = Math.ceil(timeLeftMs / (1000 * 60 * 60));
        alert(`You must wait ${timeLeftHr} more hour(s) before renaming again!`);
        return;
      }
      const newSnap = await db.ref("accounts/" + newNameInput).once("value");
      if (newSnap.exists()) {
        alert("That username is taken.");
        return;
      }
      try {
        renamingInProgress = true;
        await db.ref("accounts/" + currentUsername).remove();
        await db.ref("accounts/" + newNameInput).set({
          passwordHash: currentPassHash,
          createdAt: currentAccData.createdAt,
          lastRenamed: now,
          // Flag as an op if the new name is reserved.
          isOp: OP_LIST.includes(newNameInput.toLowerCase())
        });
        db.ref("typing/" + currentUsername).remove();
        if (OP_LIST.includes(newNameInput.toLowerCase())) {
          currentUsername = newNameInput.toLowerCase();
        } else {
          currentUsername = newNameInput;
        }
        localStorage.setItem("acc_username", currentUsername);
        if (myPresenceRef) { myPresenceRef.update({ username: newNameInput }); }
        alert("Renamed to " + newNameInput);
        renamingInProgress = false;
        updateAccountUI();
      } catch (err) {
        renamingInProgress = false;
        alert("Error renaming: " + err);
      }
    }

    /* =====================================================
       Change Password
       ===================================================== */
    async function changePassword() {
      if (!currentUsername || !currentPassHash) {
        alert("You are not logged in, can't change password.");
        return;
      }
      const newPass = document.getElementById("changePassInput").value.trim();
      if (!newPass) {
        alert("Enter a new password.");
        return;
      }
      const newPassHash = sha256(newPass);
      try {
        await db.ref("accounts/" + currentUsername).update({
          passwordHash: newPassHash
        });
        currentPassHash = newPassHash;
        localStorage.setItem("acc_passHash", newPassHash);
        alert("Password changed successfully!");
        document.getElementById("changePassInput").value = "";
      } catch (err) {
        alert("Error changing password: " + err);
      }
    }

    /* =====================================================
       Starting Chat & Presence
       ===================================================== */
    function startChatting() {
      if (!currentUsername) {
        const anonName = document.getElementById("anonymousInput").value.trim();
        if (!anonName) {
          alert("Please enter a name or create an account.");
          return;
        }
        if (/\s/.test(anonName)) {
          alert("Usernames cannot contain spaces.");
          return;
        }
        currentUsername = anonName;
      }
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("chatDiv").style.display = "block";
      document.getElementById("messageInput").focus();
      updateDMUI();
      setupPresence();
    }

    function returnToLogin() {
      removeUserTyping();
      if (myPresenceRef) { myPresenceRef.remove(); myPresenceRef = null; }
      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
      checkIfOP();
    }

    /* =====================================================
       Public Chat Send
       ===================================================== */
    function filterBadWords(text) {
      const badWordsLower = badWords.map(word => word.toLowerCase());
      let filtered = text;
      badWordsLower.forEach(word => {
        const regex = new RegExp("\\b" + word + "\\b", "gi");
        filtered = filtered.replace(regex, "****");
      });
      return filtered;
    }

    function sendMessage() {
      const inp = document.getElementById("messageInput");
      let text = inp.value.trim();
      if (!text) return;
      if (text.startsWith("/")) {
        handleSlashCommand(text);
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const currentTime = Date.now();
      if (currentTime - lastMessageTime < RATE_LIMIT_MS) {
        const secLeft = Math.ceil((RATE_LIMIT_MS - (currentTime - lastMessageTime)) / 1000);
        alert(`Wait ${secLeft} second(s).`);
        return;
      }
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      text = filterBadWords(text);
      let finalName = currentUsername || "Unknown";
      const isAccount = (currentUsername && currentPassHash);
      if (inGroupChat && currentGroupRoomName) {
        db.ref("groupRooms/" + currentGroupRoomName + "/messages").push({
          user: finalName,
          text: text,
          timestamp: firebase.database.ServerValue.TIMESTAMP
        });
      } else {
        db.ref("messages").push({
          user: finalName,
          text: text,
          isAccount: isAccount,
          timestamp: firebase.database.ServerValue.TIMESTAMP
        });
      }
      inp.value = "";
      inp.style.height = "40px";
      lastMessageTime = currentTime;
      if (currentUsername) { db.ref("typing/" + currentUsername).remove(); }
    }

    function displayMessage(user, text, isAccount, isBroadcast, messageKey, timestamp) {
      const ul = document.getElementById("messages");
      const li = document.createElement("li");
      li.classList.add("message-enter");
      if (messageKey) { li.setAttribute("data-key", messageKey); }
      let userColorClass = isAccount ? "account-user" : "anonymous-user";
      let colorStyle = "";
      if (accountColors[user]) {
        colorStyle = `style="color:${accountColors[user]}; font-weight:bold;"`;
      } else if (isAccount) {
        colorStyle = `style="color:#7289da;"`;
      }
      if (isBroadcast) {
        li.innerHTML = `<span class="broadcast-msg">[BROADCAST from ${user}]</span> ${text}`;
      } else {
        li.innerHTML = `<span class="${userColorClass}" ${colorStyle}>${user}</span>: ${text}`;
      }
      if (localStorage.getItem("showTimestamps") === "true" && timestamp) {
        const date = new Date(timestamp);
        li.title = date.toLocaleString();
      }
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function clearChat() {
      const confirmClear = confirm("Are you sure you want to clear the chat messages on your screen?");
      if (!confirmClear) return;
      document.getElementById("messages").innerHTML = "";
    }

    /* =====================================================
       Typing Indicators
       ===================================================== */
    function handleTyping() {
      if (!currentUsername) return;
      db.ref("typing/" + currentUsername).set(true);
      if (typingTimeout) clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => { db.ref("typing/" + currentUsername).remove(); }, 3000);
    }

    function showTypingStatus(typingObj) {
      const keys = Object.keys(typingObj).filter(u => u !== currentUsername);
      const typingDiv = document.getElementById("typingStatus");
      if (keys.length === 0) { typingDiv.textContent = ""; }
      else if (keys.length === 1) { typingDiv.textContent = `${keys[0]} is typing...`; }
      else { typingDiv.textContent = `${keys.join(", ")} are typing...`; }
    }

    /* =====================================================
       Multiple DM Support
       ===================================================== */
    function updateDMUI() {
      const warn = document.getElementById("dmLoginWarning");
      const ui = document.getElementById("dmUI");
      if (currentUsername && currentPassHash) { warn.style.display = "none"; ui.style.display = "block"; }
      else { warn.style.display = "block"; ui.style.display = "none"; }
    }

    // DM #1
    function openDM() {
      const typedName = document.getElementById("dmTargetInput").value.trim();
      if (!typedName) { alert("Please type a username to DM."); return; }
      if (!currentUsername || !currentPassHash) { alert("You must be logged in to DM."); return; }
      if (dmListener && currentDMPath) { db.ref(currentDMPath).off("child_added", dmListener); }
      const userA = currentUsername;
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDMPath = "dms/" + dmKey;
      document.getElementById("dmMessages").innerHTML = "";
      document.getElementById("dmConversation").style.display = "block";
      document.getElementById("dmMessageInput").focus();
      dmListener = db.ref(currentDMPath).on("child_added", (snap) => {
        const val = snap.val();
        displayDMMessage(val.user, val.text);
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
          playSoundNotification();
        }
      });
    }

    function displayDMMessage(sender, text) {
      const ul = document.getElementById("dmMessages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM() {
      if (!currentDMPath) { alert("No DM open. Type a username and 'Open DM' first."); return; }
      const inp = document.getElementById("dmMessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterBadWords(text);
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUsername || "Unknown";
      db.ref(currentDMPath).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    // DM #2
    function openDM2() {
      const typedName = document.getElementById("dm2TargetInput").value.trim();
      if (!typedName) { alert("Please type a username to DM (DM #2)."); return; }
      if (!currentUsername || !currentPassHash) { alert("You must be logged in to DM."); return; }
      if (dm2Listener && currentDM2Path) { db.ref(currentDM2Path).off("child_added", dm2Listener); }
      const userA = currentUsername;
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDM2Path = "dms/" + dmKey;
      document.getElementById("dm2Messages").innerHTML = "";
      document.getElementById("dm2Conversation").style.display = "block";
      document.getElementById("dm2MessageInput").focus();
      dm2Listener = db.ref(currentDM2Path).on("child_added", (snap) => {
        const val = snap.val();
        displayDM2Message(val.user, val.text);
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
          playSoundNotification();
        }
      });
    }

    function displayDM2Message(sender, text) {
      const ul = document.getElementById("dm2Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM2() {
      if (!currentDM2Path) { alert("No DM #2 open. Type a username and 'Open DM #2' first."); return; }
      const inp = document.getElementById("dm2MessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterBadWords(text);
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUsername || "Unknown";
      db.ref(currentDM2Path).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    // DM #3
    function openDM3() {
      const typedName = document.getElementById("dm3TargetInput").value.trim();
      if (!typedName) { alert("Please type a username to DM (DM #3)."); return; }
      if (!currentUsername || !currentPassHash) { alert("You must be logged in to DM."); return; }
      if (dm3Listener && currentDM3Path) { db.ref(currentDM3Path).off("child_added", dm3Listener); }
      const userA = currentUsername;
      const userB = typedName;
      const dmKey = (userA < userB) ? (userA + "_" + userB) : (userB + "_" + userA);
      currentDM3Path = "dms/" + dmKey;
      document.getElementById("dm3Messages").innerHTML = "";
      document.getElementById("dm3Conversation").style.display = "block";
      document.getElementById("dm3MessageInput").focus();
      dm3Listener = db.ref(currentDM3Path).on("child_added", (snap) => {
        const val = snap.val();
        displayDM3Message(val.user, val.text);
        if (val.user !== currentUsername) {
          showDMNotification(val.user, val.text);
          playSoundNotification();
        }
      });
    }

    function displayDM3Message(sender, text) {
      const ul = document.getElementById("dm3Messages");
      const li = document.createElement("li");
      li.textContent = `${sender}: ${text}`;
      li.classList.add("message-enter");
      ul.appendChild(li);
      ul.scrollTop = ul.scrollHeight;
    }

    function sendDM3() {
      if (!currentDM3Path) { alert("No DM #3 open. Type a username and 'Open DM' first."); return; }
      const inp = document.getElementById("dm3MessageInput");
      let text = inp.value.trim();
      if (!text) return;
      text = filterBadWords(text);
      if (currentUsername && mutedUsers[currentUsername]) {
        alert("You are muted and cannot send messages.");
        inp.value = "";
        inp.style.height = "40px";
        return;
      }
      const finalName = currentUsername || "Unknown";
      db.ref(currentDM3Path).push({
        user: finalName,
        text: text,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      inp.value = "";
      inp.style.height = "40px";
    }

    /* =====================================================
       Group Chat (Slash Commands) & Challenge Commands
       ===================================================== */
    async function handleSlashCommand(text) {
      const parts = text.split(" ");
      const cmd = parts[0].toLowerCase();
      const arg = parts[1] ? parts[1].trim() : null;
      // OP commands: if a non-approved user uses one, terminate them.
      if (cmd === "/mute" || cmd === "/unmute" || cmd === "/terminate") {
        if (!isCurrentUserOP()) {
          alert("Unauthorized op command detected. Your account will be terminated.");
          terminateAccount(currentUsername);
          return;
        }
        if (cmd === "/mute" || cmd === "/unmute") {
          handleOpCommand(cmd, arg);
          return;
        }
        if (cmd === "/terminate") {
          if (!arg) { alert("Usage: /terminate [accountName]"); }
          else { terminateAccount(arg); }
          return;
        }
      }
      // Duel Speed challenge command
      if (cmd === "/duelspeed") {
         if (!arg) { alert("Usage: /duelspeed [account]"); return; }
         initiateDuelSpeedChallenge(arg);
         return;
      }
      // Rock-Paper–Scissors challenge command
      if (cmd === "/rps") {
         if (!arg) { alert("Usage: /rps [account]"); return; }
         initiateRPSChallenge(arg);
         return;
      }
      // Accept/Decline for challenges
      if (cmd === "/accept") {
         if (pendingDuelSpeedChallenge) {
            acceptDuelSpeedChallenge();
            return;
         } else if (pendingRPSChallenge) {
            acceptRPSChallenge();
            return;
         } else { 
            alert("No pending challenge to accept.");
         }
      }
      if (cmd === "/decline") {
         if (pendingDuelSpeedChallenge) {
            declineDuelSpeedChallenge();
            return;
         } else if (pendingRPSChallenge) {
            declineRPSChallenge();
            return;
         } else { 
            alert("No pending challenge to decline.");
         }
      }
      // Other group chat commands
      switch(cmd) {
        case "/createroom":
          if (!arg) { alert("Usage: /createroom [roomName]"); return; }
          await createGroupRoom(arg);
          break;
        case "/join":
          if (!arg) { alert("Usage: /join [roomName]"); return; }
          await joinGroupRoom(arg);
          break;
        case "/invite":
          if (!arg) { alert("Usage: /invite [accountName]"); return; }
          await inviteToGroup(arg);
          break;
        case "/leave":
          leaveGroupRoom();
          break;
        default:
          alert("Unknown command.");
      }
    }

    /* ---- Duel Speed Challenge Functions ---- */
    function initiateDuelSpeedChallenge(target) {
      if (!currentUsername) {
         alert("You must be logged in to challenge someone.");
         return;
      }
      if (target.toLowerCase() === currentUsername.toLowerCase()) {
         alert("You cannot challenge yourself!");
         return;
      }
      let gameId = db.ref("games/duelspeed").push().key;
      let challengeData = {
         challenger: currentUsername,
         challenged: target,
         status: "pending",
         gameId: gameId,
         timestamp: firebase.database.ServerValue.TIMESTAMP
      };
      db.ref("duelspeedChallenges/" + gameId).set(challengeData);
      alert("Duel Speed challenge sent to " + target + "!");
    }

    function listenForDuelSpeedChallenges() {
      db.ref("duelspeedChallenges").on("child_added", function(snapshot) {
         let challenge = snapshot.val();
         if (challenge.challenged.toLowerCase() === currentUsername.toLowerCase() && challenge.status === "pending") {
            if (!pendingDuelSpeedChallenge) {
              pendingDuelSpeedChallenge = challenge;
              alert(challenge.challenger + " has challenged you to Duel Speed! Type /accept to accept or /decline to decline.");
            }
         }
      });
      db.ref("duelspeedChallenges").on("child_changed", function(snapshot) {
         let challenge = snapshot.val();
         if (challenge.challenged.toLowerCase() === currentUsername.toLowerCase() && challenge.status === "pending") {
            if (!pendingDuelSpeedChallenge) {
              pendingDuelSpeedChallenge = challenge;
              alert(challenge.challenger + " has challenged you to Duel Speed! Type /accept to accept or /decline to decline.");
            }
         }
         if (challenge.challenger.toLowerCase() === currentUsername.toLowerCase() && challenge.status === "accepted") {
            acceptedDuelSpeedChallenge = challenge;
            startDuelSpeedGame(challenge.gameId, challenge.challenger, challenge.challenged);
         }
      });
    }

    function acceptDuelSpeedChallenge() {
      if (!pendingDuelSpeedChallenge) {
          alert("No pending Duel Speed challenge.");
          return;
      }
      let gameId = pendingDuelSpeedChallenge.gameId;
      db.ref("duelspeedChallenges/" + gameId).update({ status: "accepted" });
      startDuelSpeedGame(gameId, pendingDuelSpeedChallenge.challenger, pendingDuelSpeedChallenge.challenged);
      pendingDuelSpeedChallenge = null;
    }

    function declineDuelSpeedChallenge() {
      if (!pendingDuelSpeedChallenge) {
          alert("No pending Duel Speed challenge.");
          return;
      }
      let gameId = pendingDuelSpeedChallenge.gameId;
      db.ref("duelspeedChallenges/" + gameId).remove();
      pendingDuelSpeedChallenge = null;
      alert("Duel Speed challenge declined.");
    }

    function startDuelSpeedGame(gameId, player1, player2) {
      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("duelSpeedGameDiv").style.display = "block";
      duelSpeedGameId = gameId;
      duelSpeedGameRef = db.ref("games/duelspeed/" + gameId);
      duelSpeedGameRef.once("value", function(snapshot) {
         if (!snapshot.exists()) {
            duelSpeedGameRef.set({
               players: {
                   [player1]: { clicks: 0 },
                   [player2]: { clicks: 0 }
               },
               status: "countdown",
               countdown: 3
            });
         }
         initDuelSpeedGame(gameId, player1, player2);
      });
      db.ref("duelspeedChallenges/" + gameId).remove();
    }

    function initDuelSpeedGame(gameId, player1, player2) {
      isDuelSpeedHost = (currentUsername.toLowerCase() === player1.toLowerCase());
      duelSpeedGameRef.on("value", function(snapshot) {
         let gameData = snapshot.val();
         if (!gameData) return;
         if (gameData.status === "countdown") {
            document.getElementById("duelSpeedStatus").textContent = "Starting in " + gameData.countdown + "...";
            document.getElementById("duelSpeedClickButton").disabled = true;
         } else if (gameData.status === "playing") {
            document.getElementById("duelSpeedStatus").textContent = "Go!";
            document.getElementById("duelSpeedClickButton").disabled = false;
         } else if (gameData.status === "ended") {
            document.getElementById("duelSpeedStatus").textContent = gameData.winner + " wins!";
            document.getElementById("duelSpeedClickButton").disabled = true;
            setTimeout(() => {
              document.getElementById("duelSpeedGameDiv").style.display = "none";
              document.getElementById("chatDiv").style.display = "block";
              document.getElementById("messageInput").focus();
            }, 3000);
         }
         document.getElementById("player1Counter").textContent = player1 + ": " + (gameData.players[player1].clicks || 0) + " clicks";
         document.getElementById("player2Counter").textContent = player2 + ": " + (gameData.players[player2].clicks || 0) + " clicks";
         if (gameData.status === "playing" && isDuelSpeedHost) {
            if (gameData.players[player1].clicks >= 100) {
              duelSpeedGameRef.update({ status: "ended", winner: player1 });
            } else if (gameData.players[player2].clicks >= 100) {
              duelSpeedGameRef.update({ status: "ended", winner: player2 });
            }
         }
      });
      if (isDuelSpeedHost) {
         duelSpeedCountdownInterval = setInterval(() => {
            duelSpeedGameRef.once("value", function(snapshot) {
               let gameData = snapshot.val();
               if (gameData.status === "countdown") {
                  if (gameData.countdown > 0) {
                     duelSpeedGameRef.update({ countdown: gameData.countdown - 1 });
                  } else {
                     duelSpeedGameRef.update({ status: "playing" });
                     clearInterval(duelSpeedCountdownInterval);
                  }
               }
            });
         }, 1000);
      }
    }

    function registerDuelSpeedClick() {
      duelSpeedGameRef.once("value", function(snapshot) {
         let gameData = snapshot.val();
         if (gameData.status !== "playing") return;
         let playerRef = duelSpeedGameRef.child("players/" + currentUsername + "/clicks");
         playerRef.transaction(function(currentClicks) {
            return (currentClicks || 0) + 1;
         });
      });
    }

    /* ---- Rock-Paper–Scissors (RPS) Challenge Functions ---- */
    function initiateRPSChallenge(target) {
      if (!currentUsername) {
         alert("You must be logged in to challenge someone.");
         return;
      }
      if (target.toLowerCase() === currentUsername.toLowerCase()) {
         alert("You cannot challenge yourself!");
         return;
      }
      let gameId = db.ref("games/rps").push().key;
      let challengeData = {
         challenger: currentUsername,
         challenged: target,
         status: "pending",
         gameId: gameId,
         timestamp: firebase.database.ServerValue.TIMESTAMP
      };
      db.ref("rpsChallenges/" + gameId).set(challengeData);
      alert("Rock–Paper–Scissors challenge sent to " + target + "!");
    }

    function listenForRPSChallenges() {
      db.ref("rpsChallenges").on("child_added", function(snapshot) {
         let challenge = snapshot.val();
         if (challenge.challenged.toLowerCase() === currentUsername.toLowerCase() && challenge.status === "pending") {
            if (!pendingRPSChallenge) {
              pendingRPSChallenge = challenge;
              alert(challenge.challenger + " has challenged you to Rock–Paper–Scissors! Type /accept to accept or /decline to decline.");
            }
         }
      });
      db.ref("rpsChallenges").on("child_changed", function(snapshot) {
         let challenge = snapshot.val();
         if (challenge.challenged.toLowerCase() === currentUsername.toLowerCase() && challenge.status === "pending") {
            if (!pendingRPSChallenge) {
              pendingRPSChallenge = challenge;
              alert(challenge.challenger + " has challenged you to Rock–Paper–Scissors! Type /accept to accept or /decline to decline.");
            }
         }
         if (challenge.challenger.toLowerCase() === currentUsername.toLowerCase() && challenge.status === "accepted") {
            acceptedRPSChallenge = challenge;
            startRPSGame(challenge.gameId, challenge.challenger, challenge.challenged);
         }
      });
    }

    function acceptRPSChallenge() {
      if (!pendingRPSChallenge) {
         alert("No pending Rock–Paper–Scissors challenge.");
         return;
      }
      let gameId = pendingRPSChallenge.gameId;
      db.ref("rpsChallenges/" + gameId).update({ status: "accepted" });
      startRPSGame(gameId, pendingRPSChallenge.challenger, pendingRPSChallenge.challenged);
      pendingRPSChallenge = null;
    }

    function declineRPSChallenge() {
      if (!pendingRPSChallenge) {
         alert("No pending Rock–Paper–Scissors challenge.");
         return;
      }
      let gameId = pendingRPSChallenge.gameId;
      db.ref("rpsChallenges/" + gameId).remove();
      pendingRPSChallenge = null;
      alert("Rock–Paper–Scissors challenge declined.");
    }

    function startRPSGame(gameId, player1, player2) {
      document.getElementById("chatDiv").style.display = "none";
      document.getElementById("rpsGameDiv").style.display = "block";
      rpsPlayer1 = player1;
      rpsPlayer2 = player2;
      rpsGameId = gameId;
      rpsGameRef = db.ref("games/rps/" + gameId);
      rpsGameRef.once("value", function(snapshot) {
         if (!snapshot.exists()) {
            rpsGameRef.set({
               players: {
                   [player1]: { choice: "" },
                   [player2]: { choice: "" }
               },
               status: "waiting"
            });
         }
         initRPSGame(gameId, player1, player2);
      });
      db.ref("rpsChallenges/" + gameId).remove();
    }

    function initRPSGame(gameId, player1, player2) {
      isRPSHost = (currentUsername.toLowerCase() === player1.toLowerCase());
      rpsGameRef.on("value", function(snapshot) {
         let gameData = snapshot.val();
         if (!gameData) return;
         let choice1 = gameData.players[player1].choice;
         let choice2 = gameData.players[player2].choice;
         if (choice1 !== "" && choice2 !== "" && gameData.status === "waiting") {
            let emoji1 = getEmoji(choice1);
            let emoji2 = getEmoji(choice2);
            let resultText = "";
            if (choice1 === choice2) {
              resultText = "It's a tie! Both chose " + choice1 + " " + emoji1 + ".";
            } else if (
              (choice1 === "rock" && choice2 === "scissors") ||
              (choice1 === "scissors" && choice2 === "paper") ||
              (choice1 === "paper" && choice2 === "rock")
            ) {
              resultText = player1 + " wins! " + choice1 + " " + emoji1 + " beats " + choice2 + " " + emoji2 + ".";
            } else {
              resultText = player2 + " wins! " + choice2 + " " + emoji2 + " beats " + choice1 + " " + emoji1 + ".";
            }
            rpsGameRef.update({ status: "finished", result: resultText });
         }
         if (gameData.status === "finished") {
            document.getElementById("rpsStatus").textContent = "Game Over";
            document.getElementById("rpsResult").textContent = gameData.result;
            document.getElementById("rpsChoices").style.display = "none";
            if (!rpsGameEndTimeout) {
              rpsGameEndTimeout = setTimeout(function() {
                document.getElementById("rpsGameDiv").style.display = "none";
                document.getElementById("chatDiv").style.display = "block";
                document.getElementById("messageInput").focus();
                resetRPSGame();
                rpsGameEndTimeout = null;
              }, 3000);
            }
         }
      });
    }

    function makeRPSChoice(choice) {
      rpsGameRef.once("value", function(snapshot) {
         let gameData = snapshot.val();
         if (gameData.status !== "waiting") return;
         if (gameData.players[currentUsername].choice === "") {
            rpsGameRef.child("players/" + currentUsername + "/choice").set(choice);
            document.getElementById("rpsStatus").textContent = "Waiting for opponent's choice...";
         }
      });
    }

    function resetRPSGame() {
      if (!rpsGameRef) return;
      rpsGameRef.set({
         players: {
            [rpsPlayer1]: { choice: "" },
            [rpsPlayer2]: { choice: "" }
         },
         status: "waiting"
      });
      document.getElementById("rpsStatus").textContent = "Make your choice:";
      document.getElementById("rpsResult").textContent = "";
      document.getElementById("rpsChoices").style.display = "block";
      document.getElementById("rpsPlayAgainButton").style.display = "none";
    }

    /* =====================================================
       Settings Navigation
       ===================================================== */
    function showSettingsFromLogin() {
      document.getElementById("loginDiv").style.display = "none";
      document.getElementById("settingsDiv").style.display = "block";
    }

    function goBack() {
      document.getElementById("settingsDiv").style.display = "none";
      document.getElementById("loginDiv").style.display = "block";
    }

    /* =====================================================
       Dark Mode Toggle
       ===================================================== */
    function toggleDarkMode() {
      document.body.classList.toggle("dark-mode");
      const isDark = document.body.classList.contains("dark-mode");
      localStorage.setItem("darkModeEnabled", isDark);
    }

    /* =====================================================
       GUI Size
       ===================================================== */
    function updateGuiSize() {
      const scale = document.getElementById("guiSizeRange").value;
      document.documentElement.style.fontSize = (16 * scale) + "px";
      localStorage.setItem("uiScale", scale);
      updateGuiSizeDisplay();
    }

    function updateGuiSizeDisplay() {
      const val = document.getElementById("guiSizeRange").value;
      document.getElementById("guiSizeValue").textContent = `Current Scale: ${val}x`;
    }

    /* =====================================================
       Custom Font
       ===================================================== */
    function updateFont() {
      document.body.classList.remove(
        "font-arial", "font-georgia", "font-courier", "font-comic", "font-roboto",
        "font-times", "font-verdana", "font-trebuchet", "font-lucida", "font-garamond",
        "font-helvetica", "font-tahoma", "font-impact", "font-futura", "font-open-sans", "font-lato", "font-montserrat"
      );
      const selectedFont = document.getElementById("fontSelect").value;
      document.body.classList.add(selectedFont);
      localStorage.setItem("selectedFont", selectedFont);
    }

    /* =====================================================
       Desktop Notifications
       ===================================================== */
    function toggleNotifications() {
      const isChecked = document.getElementById("notificationsToggle").checked;
      localStorage.setItem("notificationsEnabled", isChecked);
      if (isChecked) { requestNotificationPermission(); }
    }

    function requestNotificationPermission() {
      if (!("Notification" in window)) {
        alert("This browser does not support desktop notifications.");
        return;
      }
      if (Notification.permission !== "granted") {
        Notification.requestPermission().then((permission) => {
          if (permission !== "granted") {
            alert("You blocked notifications in your browser settings.");
            document.getElementById("notificationsToggle").checked = false;
            localStorage.setItem("notificationsEnabled", false);
          }
        });
      }
    }

    function showDMNotification(user, text) {
      const isNotificationsEnabled = localStorage.getItem("notificationsEnabled") === "true";
      if (!("Notification" in window) || !isNotificationsEnabled) return;
      if (document.hidden && Notification.permission === "granted") {
        new Notification("New DM from " + user, {
          body: text,
          icon: "https://via.placeholder.com/50"
        });
      }
    }

    /* =====================================================
       Member List (Presence)
       ===================================================== */
    function setupPresence() {
      if (myPresenceRef) { myPresenceRef.remove(); myPresenceRef = null; }
      const userNameForPresence = currentUsername || ("Guest_" + Math.floor(Math.random() * 10000));
      myPresenceRef = db.ref("presence").push();
      myPresenceRef.set({
        username: userNameForPresence,
        timestamp: firebase.database.ServerValue.TIMESTAMP
      });
      myPresenceRef.onDisconnect().remove();
    }

    function updateMemberList(members) {
      const uniqueMembers = {};
      let totalCount = 0;
      members.forEach(member => {
        if (!member || member.trim() === "" || member.toLowerCase().includes("anoynumus")) {
          member = "Anonymous Player";
        }
        if (OP_LIST.includes(member.toLowerCase())) return;
        uniqueMembers[member] = (uniqueMembers[member] || 0) + 1;
        totalCount += 1;
      });
      const memberListUl = document.getElementById("memberList");
      memberListUl.innerHTML = "";
      for (let member in uniqueMembers) {
        const count = uniqueMembers[member];
        const li = document.createElement("li");
        li.textContent = member + (count > 1 ? " (" + count + ")" : "");
        memberListUl.appendChild(li);
      }
      const memberCountHeader = document.getElementById("memberCountHeader");
      if(memberCountHeader) {
        memberCountHeader.textContent = "Members Online (" + totalCount + ")";
      }
    }

    /* =====================================================
       NEW SETTINGS FEATURES
       ===================================================== */
    // --- Background Music Controls ---
    const bgMusic = document.getElementById("bgMusic");
    const musicFileInput = document.getElementById("musicFileInput");
    const musicVolume = document.getElementById("musicVolume");
    musicFileInput.addEventListener("change", function() {
      const file = this.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = function(e) {
          bgMusic.src = e.target.result;
          localStorage.setItem("bgMusic", e.target.result);
          bgMusic.play();
        };
        reader.readAsDataURL(file);
      }
    });
    function toggleMusic() {
      if (bgMusic.paused) { bgMusic.play(); } else { bgMusic.pause(); }
    }
    function updateMusicVolume() {
      const vol = musicVolume.value;
      bgMusic.volume = vol;
      localStorage.setItem("musicVolume", vol);
    }
    function clearMusic() {
      bgMusic.pause();
      bgMusic.src = "";
      localStorage.removeItem("bgMusic");
      alert("Background music removed!");
    }
    // --- Chat Sound Notifications ---
    const chatSound = document.getElementById("chatSound");
    const soundToggle = document.getElementById("soundToggle");
    const soundVolume = document.getElementById("soundVolume");
    function toggleSoundNotifications() {
      const enabled = soundToggle.checked;
      localStorage.setItem("soundNotificationsEnabled", enabled);
    }
    function updateSoundVolume() {
      const vol = soundVolume.value;
      chatSound.volume = vol;
      localStorage.setItem("soundVolume", vol);
    }
    function playSoundNotification() {
      const enabled = localStorage.getItem("soundNotificationsEnabled") === "true";
      if (enabled) { chatSound.currentTime = 0; chatSound.play(); }
    }
    // --- Message Timestamps Toggle ---
    function toggleTimestamps() {
      const enabled = document.getElementById("timestampToggle").checked;
      localStorage.setItem("showTimestamps", enabled);
      alert("Message timestamp display " + (enabled ? "enabled" : "disabled") + ". (Hover over messages to see the sent time.)");
    }
  </script>
</body>
</html>
